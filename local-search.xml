<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>pwndbg调试方法</title>
    <link href="/2024/03/13/pwndbg%E8%B0%83%E8%AF%95%E6%96%B9%E6%B3%95/"/>
    <url>/2024/03/13/pwndbg%E8%B0%83%E8%AF%95%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>pwntools</title>
    <link href="/2024/03/10/pwn/pwntools/"/>
    <url>/2024/03/10/pwn/pwntools/</url>
    
    <content type="html"><![CDATA[<h3 id="asm汇编与反汇编"><a href="#asm汇编与反汇编" class="headerlink" title="asm汇编与反汇编"></a>asm汇编与反汇编</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>asm(<span class="hljs-string">&#x27;mov eax, 0&#x27;</span>)   <span class="hljs-comment">#汇编</span><br><span class="hljs-string">&#x27;\xb8\x00\x00\x00\x00&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>disasm(<span class="hljs-string">&#x27;\xb8\x0b\x00\x00\x00&#x27;</span>)  <span class="hljs-comment">#反汇编</span><br><span class="hljs-string">&#x27;   0:   b8 0b 00 00 00          mov    eax,0xb&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="elf文件操作"><a href="#elf文件操作" class="headerlink" title="elf文件操作"></a>elf文件操作</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>e = ELF(<span class="hljs-string">&#x27;/bin/cat&#x27;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span> <span class="hljs-built_in">hex</span>(e.address)  <span class="hljs-comment"># 文件装载的基地址</span><br><span class="hljs-number">0x400000</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span> <span class="hljs-built_in">hex</span>(e.symbols[<span class="hljs-string">&#x27;write&#x27;</span>]) <span class="hljs-comment"># 函数地址</span><br><span class="hljs-number">0x401680</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span> <span class="hljs-built_in">hex</span>(e.got[<span class="hljs-string">&#x27;write&#x27;</span>]) <span class="hljs-comment"># GOT表的地址</span><br><span class="hljs-number">0x60b070</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span> <span class="hljs-built_in">hex</span>(e.plt[<span class="hljs-string">&#x27;write&#x27;</span>]) <span class="hljs-comment"># PLT的地址</span><br><span class="hljs-number">0x401680</span><br></code></pre></td></tr></table></figure><h3 id="shellcode使用"><a href="#shellcode使用" class="headerlink" title="shellcode使用"></a>shellcode使用</h3><p><strong>pwnlib.shellcraft模块</strong>包含<strong>生成shell代码</strong>的函数。<br>其中的子模块声明结构，比如</p><ul><li>ARM架构: shellcraft.arm</li><li>AMD64架构: shellcraft.amd64</li><li>Intel 80386架构: shellcraft.i386</li><li>通用: shellcraft.common</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><br>context(arch=<span class="hljs-string">&#x27;i386&#x27;</span>, os=<span class="hljs-string">&#x27;linux&#x27;</span>)<br>shellcode = asm(shellcraft.sh())<br></code></pre></td></tr></table></figure><h3 id="remote-process读写接口"><a href="#remote-process读写接口" class="headerlink" title="remote&#x2F;process读写接口"></a>remote&#x2F;process读写接口</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 第一种连接方式，通过ip和port去连接</span><br>conn = remote(<span class="hljs-string">&#x27;127.0.0.1&#x27;</span>, <span class="hljs-number">8888</span>)  <br><span class="hljs-comment"># 第二种连接方式，通过ssh连接</span><br>shell = ssh(host=<span class="hljs-string">&#x27;192.168.14.144&#x27;</span>, user=<span class="hljs-string">&#x27;root&#x27;</span>, port=<span class="hljs-number">2222</span>, password=<span class="hljs-string">&#x27;123456&#x27;</span>)<br><br><span class="hljs-comment">#接受或者发送数据</span><br>conn.send(data) <span class="hljs-comment">#发送数据</span><br>conn.sendline(data) <span class="hljs-comment">#发送一行数据，相当于在数据后面加\n</span><br><span class="hljs-comment">#接收数据，numb制定接收的字节，timeout指定超时</span><br>conn.recv(numb = <span class="hljs-number">2048</span>, timeout = default)<br><span class="hljs-comment">#接受一行数据，keepends为是否保留行尾的\n</span><br>conn.recvline(keepends=<span class="hljs-literal">True</span>)<br><span class="hljs-comment">#接受数据直到我们设置的标志出现</span><br>conn.recvuntil(<span class="hljs-string">&quot;Hello,World\n&quot;</span>,drop=fasle) <br>conn.recvall()  <span class="hljs-comment">#一直接收直到 EOF</span><br>conn.recvrepeat(timeout = default)  <span class="hljs-comment">#持续接受直到EOF或timeout</span><br><span class="hljs-comment">#直接进行交互，相当于回到shell的模式，在取得shell之后使用</span><br>conn.interactive()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>pwn</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>获取地址</title>
    <link href="/2024/03/09/pwn/%E8%8E%B7%E5%8F%96%E5%9C%B0%E5%9D%80/"/>
    <url>/2024/03/09/pwn/%E8%8E%B7%E5%8F%96%E5%9C%B0%E5%9D%80/</url>
    
    <content type="html"><![CDATA[<p>在漏洞利用的过程中，我们常常需要获取一些变量，函数的地址，以便于能够进行进一步的利用。这里我将获取地址的方法分为如下几类</p><ul><li>直接寻找地址，即我们可以通过反编译等手段直接看到对应符号的地址。</li><li>泄漏地址，即需要我们通过控制程序的执行流来泄漏程序中的某些符号指针的内容，来获取对应的地址。</li><li>推测地址，这里我们一般常用的就是根据某个段内的符号之间的偏移是固定的，从而来推断一些新的符号的地址。</li><li>猜测地址，一般主要指的是，我们需要自己去猜测对应符号的地址，这里伴随的往往就是暴力枚举了。</li></ul><p>上述几种方法，是一种递进地考虑方式，我们在获取相关符号的地址时，应保持这样的思考方式。</p><p>在上面的几种方式中，我认为主要有两点核心思想</p><ul><li>充分利用代码本身的性质，比如程序某些代码的位置就是固定的，如不开启 PIE 时，代码段的位置；再比如，glibc 的后三位是固定的。</li><li>充分利用相对偏移的性质，这是由于目前程序加载时往往加载的内存都是一段一段的，所以相对偏移往往是固定的。</li></ul><p>更加具体的，我们可以看如下的介绍。</p><h3 id="直接寻找地址"><a href="#直接寻找地址" class="headerlink" title="直接寻找地址"></a>直接寻找地址</h3><p>程序中已经给出了相关变量或者函数的地址了。这时候，我们就可以直接进行利用了。</p><p>这种情形往往适用于程序没有开启 PIE 的情况。</p><h3 id="泄漏地址"><a href="#泄漏地址" class="headerlink" title="泄漏地址"></a>泄漏地址</h3><p>在泄漏地址的过程中，我们往往需要找到一些敏感的指针，这些指针里存储着要么就是我们想要的符号的地址，要么就是与我们想要的符号的地址相关。</p><p>下面给出几个例子。</p><h4 id="泄漏变量指针"><a href="#泄漏变量指针" class="headerlink" title="泄漏变量指针"></a>泄漏变量指针</h4><p>比如</p><ol><li>泄漏 main arena 中各种 bin 的头表指针，可能就可以获取堆中或者 glibc 中某个变量的地址。</li></ol><h4 id="泄漏-got-表"><a href="#泄漏-got-表" class="headerlink" title="泄漏 got 表"></a>泄漏 got 表</h4><p>有时候我们并不一定非得直接知道某个函数的地址，可以利用 GOT 表跳转到对应函数的地址。当然，如果我们非得知道这个函数的地址，我们可以利用 write，puts 等输出函数将 GOT 表中地址处对应的内容输出出来（<strong>前提是这个函数已经被解析一次了</strong>）。</p><h4 id="ret2dl-resolve"><a href="#ret2dl-resolve" class="headerlink" title="ret2dl-resolve"></a>ret2dl-resolve</h4><p>当 ELF 文件采用动态链接时，got 表会采用延迟绑定技术。当第一次调用某个 libc 函数时，程序会调用_dl_runtime_resolve 函数对其地址解析。因此，我们可以利用栈溢出构造 ROP 链，伪造对其他函数（如：system）的解析。这也是我们在高级 rop 中介绍的技巧。</p><h4 id="proc-self-maps"><a href="#proc-self-maps" class="headerlink" title="&#x2F;proc&#x2F;self&#x2F;maps"></a>&#x2F;proc&#x2F;self&#x2F;maps</h4><p>我们可以考虑通过读取程序的 <code>/proc/self/maps</code>来获取与程序相关的基地址。</p><h3 id="推测地址"><a href="#推测地址" class="headerlink" title="推测地址"></a>推测地址</h3><p>在大多数情况下，我们都不能直接获取想要的函数的地址，往往需要进行一些地址的推测，正如上面所说，这里就重点依赖于符号间的偏移是固定的这一思想。</p><h4 id="Stack-Related"><a href="#Stack-Related" class="headerlink" title="Stack Related"></a>Stack Related</h4><p>关于栈上的地址，其实我们大多时候并不需要具体的栈地址，但是我们可以根据栈的寻址方式，推测出栈上某个变量相对于 EBP 的位置。</p><h4 id="Glibc-Related"><a href="#Glibc-Related" class="headerlink" title="Glibc Related"></a>Glibc Related</h4><p>这里主要考虑的是如何找到 Glibc 中相关的函数。</p><h5 id="有-libc"><a href="#有-libc" class="headerlink" title="有 libc"></a>有 libc</h5><p>这时候我们就需要考虑利用 libc 中函数的基地址一样这个特性来寻找了。比如我们可以通过 __libc_start_main 的地址来泄漏 libc 在内存中的基地址。</p><p><strong>注意：不要选择有 wapper 的函数，这样会使得函数的基地址计算不正确。</strong></p><p>常见的有 wapper 的函数有？（待补充）。</p><h5 id="无-libc"><a href="#无-libc" class="headerlink" title="无 libc"></a>无 libc</h5><p>其实，这种情况的解决策略分为两种</p><ul><li>想办法获取 libc</li><li>想办法直接获取对应的地址。</li></ul><p>而对于想要泄露的地址，我们只是单纯地需要其对应的内容，所以 puts ， write，printf 均可以。</p><ul><li>puts，printf 会有 \x00 截断的问题</li><li>write 可以指定长度输出的内容。</li></ul><p>下面是一些相应的方法</p><h4 id="PWNLIB-DYNELF"><a href="#PWNLIB-DYNELF" class="headerlink" title="PWNLIB.DYNELF"></a>PWNLIB.DYNELF</h4><p>前提是我们可以泄露任意地址的内容。</p><ul><li><strong>如果要使用 write 函数泄露的话，一次最好多输出一些地址的内容，因为我们一般是只是不断地向高地址读内容，很有可能导致高地址的环境变量被覆盖，就会导致 shell 不能启动。</strong></li></ul><h4 id="LIBC-数据库"><a href="#LIBC-数据库" class="headerlink" title="LIBC 数据库"></a>LIBC 数据库</h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># 更新数据库</span><br>./<span class="hljs-built_in">get</span><br><span class="hljs-comment"># 将已有libc添加到数据库中</span><br>./<span class="hljs-built_in">add</span> libc.so <br><span class="hljs-comment"># Find all the libc&#x27;s in the database that have the given names at the given addresses. </span><br>./<span class="hljs-built_in">find</span> function1 addr function2 addr<br><span class="hljs-comment"># Dump some useful offsets, given a libc ID. You can also provide your own names to dump.</span><br>./dump __libc_start_main_ret<span class="hljs-built_in"> system </span>dup2<br></code></pre></td></tr></table></figure><p>去 libc 的数据库中找到对应的和已经出现的地址一样的 libc，这时候很有可能是一样的。</p><p>也可以使用如下的在线网站:</p><ul><li><a href="http://libcdb.com/">libcdb.com</a></li><li><a href="https://libc.blukat.me/">libc.blukat.me</a></li></ul><p><strong>当然，还有上面提到的 <a href="https://github.com/lieanu/LibcSearcher%E3%80%82">https://github.com/lieanu/LibcSearcher。</a></strong></p><h4 id="Heap-related"><a href="#Heap-related" class="headerlink" title="Heap related"></a>Heap related</h4><p>关于堆的一些地址的推测，这就需要我们比较详细地知道堆里分配了多少内存，目前泄漏出的内存地址是哪一块，进而获取堆的基地址，以及堆中相关的内存地址。</p><h2 id="猜测地址"><a href="#猜测地址" class="headerlink" title="猜测地址"></a>猜测地址</h2><p>在一些比较奇怪的情况下，我们可能可以使用如下的方式</p><ul><li>使用一些暴力的方法来获取地址，比如 32 位时，地址随机化的空间比较小。</li><li>当程序被特殊部署时，其不同的库被加载的位置可能会比较特殊。我们可以在本地尝试，然后猜测远程的情况。</li></ul>]]></content>
    
    
    <categories>
      
      <category>pwn</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>linux程序的保护机制</title>
    <link href="/2024/03/09/pwn/linux%E7%A8%8B%E5%BA%8F%E7%9A%84%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/"/>
    <url>/2024/03/09/pwn/linux%E7%A8%8B%E5%BA%8F%E7%9A%84%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h3 id="一、常见的保护程序方法"><a href="#一、常见的保护程序方法" class="headerlink" title="一、常见的保护程序方法"></a>一、常见的保护程序方法</h3><h4 id="0011-CANNARY-栈保护"><a href="#0011-CANNARY-栈保护" class="headerlink" title="0011.CANNARY(栈保护)"></a>0011.CANNARY(栈保护)</h4><p>​栈溢出保护是一种缓冲区溢出攻击缓解手段，当函数存在缓冲区溢出攻击漏洞时，攻击者可以覆盖栈上的返回地址来让shellcode能够得到执行。当启用栈保护后，函数开始执行的时候会先往栈里插入cookie信息，当函数真正返回的时候会验证cookie信息是否合法，如果不合法就停止程序运行。攻击者在覆盖返回地址的时候往往也会将cookie信息给覆盖掉，导致栈保护检查失败而阻止shellcode的执行。在Linux中我们将cookie信息称为canary。</p><h4 id="2-FORTIFY"><a href="#2-FORTIFY" class="headerlink" title="2.FORTIFY"></a>2.FORTIFY</h4><p>​fority其实非常轻微的检查，用于检查是否存在缓冲区溢出的错误。适用情形是程序采用大量的字符串或者内存操作函数，如memcpy，memset，stpcpy，strcpy，strncpy，strcat，strncat，sprintf，snprintf，vsprintf，vsnprintf，gets以及宽字符的变体。</p><p><em>FORTIFY_SOURCE设为1，并且将编译器设置为优化1(<em>gcc -O1</em>)，以及出现上述情形，那么程序编译时就会进行检查但又不会改变程序功能</em><br>FORTIFY_SOURCE设为2，有些检查功能会加入，但是这可能导致程序崩溃。</p><p>gcc -D_FORTIFY_SOURCE&#x3D;1<code>仅仅只会在编译时进行检查 (特别像某些头文件</code>#include &lt;string.h&gt;<code>)</code><br>gcc -D_FORTIFY_SOURCE&#x3D;2&#96; 程序执行时也会有检查 (如果检查到缓冲区溢出，就终止程序)</p><h4 id="3-NX（DEP）"><a href="#3-NX（DEP）" class="headerlink" title="3.NX（DEP）"></a>3.NX（DEP）</h4><p>​NX即No-eXecute（不可执行）的意思，NX（DEP）的基本原理是将数据所在内存页标识为不可执行，当程序溢出成功转入shellcode时，程序会尝试在数据页面上执行指令，此时CPU就会抛出异常，而不是去执行恶意指令。</p><h4 id="4-PIE（ASLR）"><a href="#4-PIE（ASLR）" class="headerlink" title="4.PIE（ASLR）"></a>4.PIE（ASLR）</h4><p>一般情况下NX（Windows平台上称其为DEP）和地址空间分布随机化（ASLR）会同时工作。<br>内存地址随机化机制（address space layout randomization)，有以下三种情况</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">0 </span>- 表示关闭进程地址空间随机化。<br><span class="hljs-symbol">1 </span>- 表示将mmap的基址，stack和vdso页面随机化。<br><span class="hljs-symbol">2 </span>- 表示在<span class="hljs-number">1</span>的基础上增加栈（heap）的随机化。<br></code></pre></td></tr></table></figure><p>可以防范基于Ret2libc方式的针对DEP的攻击。ASLR和DEP配合使用，能有效阻止攻击者在堆栈上运行恶意代码。</p><p>Built as PIE：位置独立的可执行区域（position-independent executables）。这样使得在利用缓冲溢出和移动操作系统中存在的其他内存崩溃缺陷时采用面向返回的编程（return-oriented programming）方法变得难得多。</p>]]></content>
    
    
    <categories>
      
      <category>pwn</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>python 打包程序逆向</title>
    <link href="/2024/03/09/%E9%80%86%E5%90%91/python%20%E6%89%93%E5%8C%85%E7%A8%8B%E5%BA%8F%E9%80%86%E5%90%91/"/>
    <url>/2024/03/09/%E9%80%86%E5%90%91/python%20%E6%89%93%E5%8C%85%E7%A8%8B%E5%BA%8F%E9%80%86%E5%90%91/</url>
    
    <content type="html"><![CDATA[<h4 id="1-用-Detect-It-Easy查看："><a href="#1-用-Detect-It-Easy查看：" class="headerlink" title="1.用 Detect It Easy查看："></a>1.用 Detect It Easy查看：</h4><p>打包工具为pyinstaller</p><h4 id="2-反编译可执行程序"><a href="#2-反编译可执行程序" class="headerlink" title="2.反编译可执行程序"></a>2.反编译可执行程序</h4><p>我们下载反编译工具<strong>pyinstxtractor.py</strong>与我们要反编译的.exe文件放入同一个工作目录下，如下图所示：</p><p><img src="https://bbs.kanxue.com/upload/attach/202306/909733_X2KAP5KQVCZ9UWP.png" alt="图片描述"></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">.\pyinstxtractor.<span class="hljs-keyword">py</span> 测试脚本.<span class="hljs-keyword">exe</span><br></code></pre></td></tr></table></figure><p>执行完毕，看到<code>Successfully</code>字样，会生成<code>测试脚本.exe_extracted</code>文件夹，如下图所示：<br><img src="https://bbs.kanxue.com/upload/attach/202306/909733_TSVJWEKQZXT6H2V.png" alt="图片描述"><br>进入该文件夹，里面有许许多多后缀为<code>.dll</code>和<code>.pyd</code>的文件，还有一个名为<code>PYZ-00.pyz_extracted</code>的文件夹，这个文件夹里放的是程序引入的<code>依赖库</code>，如果你引入过自己其他的<code>.py</code>文件，就可以用类似的方法将依赖的<code>.py</code>文件反编译出来，如下图所示：<br><img src="https://bbs.kanxue.com/upload/attach/202306/909733_P5ZJS35R4ZH64FK.png" alt="图片描述"><br>在目录中我们要找到<code>struct</code>和与你的<code>.exe</code>文件同名的文件。如下图所示：<br><img src="https://bbs.kanxue.com/upload/attach/202306/909733_N58BJTSJQ6UH42K.png" alt="图片描述"><br>这两个文件是否带<code>.pyc</code>后缀和你使用的<code>pyinstxtractor.py</code>工具版本有关系。V2.0以前的版本，会生成两个不带<code>.pyc</code>后缀的文件，手动为它添加<code>.pyc</code>后缀即可。如下图所示：<br><img src="https://bbs.kanxue.com/upload/attach/202306/909733_KK2YYUE5ERUAB9J.png" alt="图片描述"><br>当前这个<code>测试脚本.pyc</code>文件是没有<code>Magic Number</code>的，我们需要根据Python版本自行补全，由上图可知打包此程序的Python版本为3.6，我们接下来就需要查3.6版本的<code>Magic Number</code>。</p><h4 id="3-看struct-pyc文件："><a href="#3-看struct-pyc文件：" class="headerlink" title="3.看struct.pyc文件："></a>3.看<code>struct.pyc</code>文件：</h4><p>将<code>struct.pyc</code>文件使用<code>WinHex编辑器</code>打开，它的前4位字节就是<code>magic num</code>与方法一的二进制码相同。如下图所示：<br><img src="https://bbs.kanxue.com/upload/attach/202306/909733_QSGE9VP6YBE9W6Y.png" alt="图片描述"><br>再打开<code>测试脚本.pyc</code>与<code>struct.pyc</code>对比头内容确定要添加的内容，如下图所示：<br><img src="https://bbs.kanxue.com/upload/attach/202306/909733_ATGJ9GJEUGXUUBA.png" alt="图片描述"></p><p>改pyc文件</p><p>选中<code>struct.pyc</code>中框选的头内容，右键编辑→复制选块→十六进制数值。<code>330D0D0A7079693001010000</code><br><img src="https://bbs.kanxue.com/upload/attach/202306/909733_JFKCBG5M4T94S3H.png" alt="图片描述"><br>打开<code>测试脚本.pyc</code>，直接在前面添加，上面复制的十六进制数值<code>330D0D0A7079693001010000</code>，光标点击第一个字母<code>E</code>右键编辑→剪贴板数据→粘贴→ASCII Hex→确定，然后保存即修改完毕！如下图所示：<br><img src="https://bbs.kanxue.com/upload/attach/202306/909733_YMPPVDSANDUS5WY.png" alt="图片描述"><br><img src="https://bbs.kanxue.com/upload/attach/202306/909733_AXX35TQDYDNFVH2.png" alt="图片描述"><br><img src="https://bbs.kanxue.com/upload/attach/202306/909733_RE992TMUU9HFHUP.png" alt="图片描述"></p><h4 id="4-pyc文件转换为py文件"><a href="#4-pyc文件转换为py文件" class="headerlink" title="4.pyc文件转换为py文件"></a>4.pyc文件转换为py文件</h4><p>找到<code>测试脚本.pyc</code>所在的文件夹，<code>cd</code> 到此路径下，并输入以下打包命令：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">uncompyle6 -o 测试脚本<span class="hljs-string">.py</span> 测试脚本<span class="hljs-string">.pyc</span><br></code></pre></td></tr></table></figure><p>命令执行完毕后，会看到<code>successfully</code>字段，表示<code>.py</code>源码文件已成功生成在同路径下。<br><img src="https://bbs.kanxue.com/upload/attach/202306/909733_VB2KNPETFQ3TFW2.png" alt="图片描述"></p>]]></content>
    
    
    <categories>
      
      <category>逆向</category>
      
    </categories>
    
    
    <tags>
      
      <tag>pyc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>花指令</title>
    <link href="/2024/03/09/%E9%80%86%E5%90%91/%E8%8A%B1%E6%8C%87%E4%BB%A4/"/>
    <url>/2024/03/09/%E9%80%86%E5%90%91/%E8%8A%B1%E6%8C%87%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>花指令是企图隐藏掉不想被逆向工程的代码块(或其它功能)的一种方法，在真实代码中插入一些垃圾代码的同时还保证原有程序的正确执行，而程序无法很好地反编译, 难以理解程序内容，达到混淆视听的效果。简单的说就是在代码中混入一些垃圾数据阻碍你的静态分析。</p><h2 id="花指令分类"><a href="#花指令分类" class="headerlink" title="花指令分类"></a>花指令分类</h2><p>花指令大致可以分为可执行花指令和不可执行花指令两类：</p><h3 id="可执行花指令"><a href="#可执行花指令" class="headerlink" title="可执行花指令"></a>可执行花指令</h3><p>可执行花指令指的是这部分花指令代码在程序的正常执行过程中会被执行</p><ul><li>但执行这些代码没有任何意义</li><li>执行前后不改变任何寄存器的值(当然eip这种除外)</li><li>同时这部分代码也会被反汇编器正常识别</li></ul><p><strong>目的</strong></p><ol><li>首先，花指令的首要目的依然是加大静态分析的难度,让你难以识别代码的真正意图</li><li>然后，这种花指令可以破坏反编译的分析,使得栈指针在反编译引擎中出现异常。(当然我们知道栈指针实际上是没有问题的,只不过反编译引擎还有待完善的空间)</li></ol><h3 id="不可执行式花指令"><a href="#不可执行式花指令" class="headerlink" title="不可执行式花指令"></a>不可执行式花指令</h3><p>不可执行花指令指的是这部分花指令代码在程序的正常执行过程中不会被执行</p><p>不可执行花指令是利用反汇编器线性扫描算法的缺陷使得静态分析的时候会看到一些错误的代码</p><h2 id="最常见的花指令"><a href="#最常见的花指令" class="headerlink" title="最常见的花指令"></a>最常见的花指令</h2><p><img src="https://i.loli.net/2020/06/16/QKGzB7fnACNy4kS.png" alt="image-20200616211207943"></p><p>如图所示,这就是ctf题目中最常见也是最简单花指令之一，一个典型的不可执行花指令。</p><h3 id="patch方法"><a href="#patch方法" class="headerlink" title="patch方法"></a>patch方法</h3><p>首先我们将0x00401D92处的代码转换成数据（快捷键U）</p><p><img src="https://i.loli.net/2020/06/16/Cl62vX8Qyu9mz4E.png" alt="image-20200616211824836"></p><p>然后将0x00401D94处的数据转换成代码（快捷键C），再把0x00401D92，0x00401D93处的数据nop掉即可</p><p><img src="https://i.loli.net/2020/06/16/nbgyGfT9C8eNrHw.png" alt="image-20200616212021916"></p><p>我们知道E9是jmp指令对应的机器码，当反汇编器读取到E9时，接着会往下读取四个字节的数据作为跳转地址的偏移，所以才会看到错误的汇编代码。</p><h3 id="编写方法"><a href="#编写方法" class="headerlink" title="编写方法"></a>编写方法</h3><p>如果我们在写程序的时候嵌入_asm _emit 0E9，反编译器就会把下一条指令当做地址数据，不管下一条指令实际上的四个字节是地址数据还是操作指令。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs assembly">__asm &#123; <br>    _emit 075h    #jmp $+4<br>    _emit 2h<br>    _emit 0E9h<br>    _emit 0EDh<br>&#125;<br></code></pre></td></tr></table></figure><p>上面嵌入的4字节数据即可使得程序反汇编反编译出错，注意这里的75是jnz的机器码，所以要求程序执行到这里时Zflag&#x3D;0。</p><h2 id="具体例子"><a href="#具体例子" class="headerlink" title="具体例子"></a>具体例子</h2><h3 id="无花指令源程序"><a href="#无花指令源程序" class="headerlink" title="无花指令源程序"></a>无花指令源程序</h3><p>这里我写了一个tea加密算法，我们用msvc编译，生成完成pdb文件方便分析，然后ida打开</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdint.h&gt;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">encrypt</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span>* v, <span class="hljs-type">uint32_t</span>* k)</span> &#123;<br>    <span class="hljs-type">uint32_t</span> v0 = v[<span class="hljs-number">0</span>], v1 = v[<span class="hljs-number">1</span>], sum = <span class="hljs-number">0</span>, i;           <span class="hljs-comment">/* set up */</span><br>    <span class="hljs-type">uint32_t</span> delta = <span class="hljs-number">0x9e3779b9</span>;                     <span class="hljs-comment">/* a key schedule constant */</span><br>    <span class="hljs-type">uint32_t</span> k0 = k[<span class="hljs-number">0</span>], k1 = k[<span class="hljs-number">1</span>], k2 = k[<span class="hljs-number">2</span>], k3 = k[<span class="hljs-number">3</span>];   <span class="hljs-comment">/* cache key */</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">32</span>; i++) &#123;                       <span class="hljs-comment">/* basic cycle start */</span><br>        sum += delta;<br>        v0 += ((v1 &lt;&lt; <span class="hljs-number">4</span>) + k0) ^ (v1 + sum) ^ ((v1 &gt;&gt; <span class="hljs-number">5</span>) + k1);<br>        v1 += ((v0 &lt;&lt; <span class="hljs-number">4</span>) + k2) ^ (v0 + sum) ^ ((v0 &gt;&gt; <span class="hljs-number">5</span>) + k3);<br>    &#125;                                              <span class="hljs-comment">/* end cycle */</span><br>    v[<span class="hljs-number">0</span>] = v0; v[<span class="hljs-number">1</span>] = v1;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">uint32_t</span> flag[] = &#123; <span class="hljs-number">1234</span>,<span class="hljs-number">5678</span> &#125;;<br>    <span class="hljs-type">uint32_t</span> key[] = &#123; <span class="hljs-number">9</span>,<span class="hljs-number">9</span>,<span class="hljs-number">9</span>,<span class="hljs-number">9</span> &#125;;<br>    encrypt(flag, key);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d,%d&quot;</span>, flag[<span class="hljs-number">0</span>], flag[<span class="hljs-number">1</span>]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先可以看到main函数和源代码差别不大</p><p><img src="https://i.loli.net/2020/06/16/D9IA7JpvozLSgG1.png" alt="image-20200616234950510"></p><p>然后可以看到encrypt函数也和源代码基本一样</p><p><img src="https://i.loli.net/2020/06/16/C2kvb5D7ZUFd6Lo.png" alt="image-20200616235055960"></p><h3 id="加入花指令"><a href="#加入花指令" class="headerlink" title="加入花指令"></a>加入花指令</h3><p>接下来我们加入两个花指令</p><p>第一个花指令在main函数中，就是我们上面提供的最简单的花指令编写方法</p><p>第二个花指令在encrypt函数中，是一个可执行花指令，下面我会具体分析这个花指令以及对应的去除方法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><br></code></pre></td></tr></table></figure><p><strong>第一个花指令</strong></p><p>首先ida打开查看main函数：</p><p><img src="https://i.loli.net/2020/06/16/QLenNRbvAsUH4ct.png" alt="image-20200616235743442"></p><p>虽然还是反编译成功了，但是可以看到内容已经完全错误，我们再来看main函数的汇编代码，也就是我们加入的第一个花指令</p><p><img src="https://i.loli.net/2020/06/16/ZLF2XBCcIl8gwzT.png" alt="image-20200616235852756"></p><p>可以看到这里出现的红色就是我们的第一处花指令，patch方法同上，我们主要看第二处花指令。</p><p><strong>第二个花指令</strong></p><p>f5反编译直接报错</p><p><img src="https://i.loli.net/2020/06/17/NFG2ck1tTsA7XwV.png" alt="image-20200617000152860"></p><p>可以发现花指令的混淆作用还是很明显的，那我们继续跟进到花指令的反汇编代码处</p><p><img src="https://i.loli.net/2020/06/17/sEZLmS7FqPkfUJN.png" alt="image-20200617000420510"></p><p>这里框出的指令就是我们加入的花指令，逻辑其实特别清晰，就是先跳转到junk1，再call junk2，call junk2的时候会把地址0x004118D3压栈，然后进入junk2中执行retn指令又会把地址0x004118D3 pop到eip中，然后接下来程序继续正常执行。</p><p><strong>去除方法</strong></p><p>这种连续的可执行花指令的去除方法特别简单，直接整块nop掉即可。</p><p>但是真正的复杂程序里这种花指令的数量很多，人工nop很耗时，同时极容易出错，所以我们真正应该掌握的是自动化的方法，编写脚本匹配花指令模板进行去除。</p><h3 id="去除花指令"><a href="#去除花指令" class="headerlink" title="去除花指令"></a>去除花指令</h3><p>这里是我们要去除的花指令模板</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs assembly">#define JUNKCODE __asm&#123;<br>    __asm jmp junk1 <br>    __asm __emit 0x12 <br>    __asm junk2: <br>    __asm ret <br>    __asm __emit 0x34 <br>    __asm junk1: <br>    __asm call junk2  <br>&#125;<br></code></pre></td></tr></table></figure><p>这里是idapython编写的ida匹配模板去除花指令脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">nop</span>(<span class="hljs-params">addr, endaddr</span>):<br>    <span class="hljs-keyword">while</span> addr &lt; endaddr:<br>        PatchByte(addr, <span class="hljs-number">0x90</span>)<br>        addr += <span class="hljs-number">1</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">undefine</span>(<span class="hljs-params">addr, endaddr</span>):<br>    <span class="hljs-keyword">while</span> addr &lt; endaddr:<br>        MakeUnkn(addr, <span class="hljs-number">0</span>)<br>        addr += <span class="hljs-number">1</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">dejunkcode</span>(<span class="hljs-params">addr, endaddr</span>):<br>    <span class="hljs-keyword">while</span> addr &lt; endaddr:<br>        MakeCode(addr)<br>        <span class="hljs-comment"># 匹配模板</span><br>        <span class="hljs-keyword">if</span> GetMnem(addr) == <span class="hljs-string">&#x27;jmp&#x27;</span> <span class="hljs-keyword">and</span> GetOperandValue(addr, <span class="hljs-number">0</span>) == addr + <span class="hljs-number">5</span> <span class="hljs-keyword">and</span> Byte(addr+<span class="hljs-number">2</span>) == <span class="hljs-number">0x12</span>:<br>            <span class="hljs-built_in">next</span> = addr + <span class="hljs-number">10</span><br>            nop(addr, <span class="hljs-built_in">next</span>)<br>            addr = <span class="hljs-built_in">next</span><br>            <span class="hljs-keyword">continue</span><br>        addr += ItemSize(addr)<br><br>dejunkcode(<span class="hljs-number">0x00411820</span>, <span class="hljs-number">0x00411957</span>)<br>undefine(<span class="hljs-number">0x00411820</span>, <span class="hljs-number">0x00411957</span>)<br>MakeFunction(<span class="hljs-number">0x00411820</span>, -<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p><strong>重要函数解析</strong></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">MakeCode</span>(ea) #分析代码区，相当于ida快捷键C<br><span class="hljs-built_in">ItemSize</span>(ea) #获取指令或数据长度<br><span class="hljs-built_in">GetMnem</span>(ea) #得到addr地址的操作码<br><span class="hljs-built_in">GetOperandValue</span>(ea,n) #返回指令的操作数的被解析过的值<br><span class="hljs-built_in">PatchByte</span>(ea, value) #修改程序字节<br><span class="hljs-built_in">Byte</span>(ea) #将地址解释为Byte<br><span class="hljs-built_in">MakeUnkn</span>(ea,<span class="hljs-number">0</span>) <span class="hljs-selector-id">#MakeCode</span>的反过程，相当于ida快捷键U<br><span class="hljs-built_in">MakeFunction</span>(ea,end) #将有begin到end的指令转换成一个函数。如果end被指定为BADADDR（-<span class="hljs-number">1</span>），IDA会尝试通过定位函数的返回指令，来自动确定该函数的结束地址<br></code></pre></td></tr></table></figure><p>idapython提供的函数挺多的，这里的函数如果有不太理解意思的，可以在ida的python命令行中自行尝试一下，对照着ida汇编窗口的变化和函数返回值很快就能掌握函数的用法</p><p><strong>运行脚本</strong></p><p>我们在ida中运行脚本，然后可以发现那段花指令已经成功nop掉了，按下f5反编译：</p><p><img src="https://i.loli.net/2020/06/17/k17OfWKzrqib6GY.png" alt="image-20200617002951207"></p><p>可以看到encrypt函数被成功的反编译了。</p><p>对于较复杂的程序而言，编写模板匹配脚本去除花指令是十分重要的，可以做到准确无误，同时节省了很多时间。</p><h3 id="特殊花指令"><a href="#特殊花指令" class="headerlink" title="特殊花指令"></a>特殊花指令</h3><p>还有一类较特殊的花指令，它不会影响反汇编和反编译，只是单纯的混淆视听</p><p>譬如我们程序需要将某个特定值（这里假设是0x12）压栈，正常操作应该是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">push    0x12<br></code></pre></td></tr></table></figure><p>加入花指令后，这个操作可以变成这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">push    0x26<br>xor dword ptr ss:[esp], 0x34<br></code></pre></td></tr></table></figure><p>我们很容易可以看出来这两种写法是等效的，当我们要压栈的数据是一些很明显的特征值的时候，这种花指令可以很好的保护我们的特征值，防止算法特征被迅速识别</p><p>当然这里只是一个简单的例子，这种花指令复杂起来将会使得分析难度大大提升。</p>]]></content>
    
    
    <categories>
      
      <category>逆向</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>c&#92;c++的输入输出</title>
    <link href="/2024/03/09/%E7%BC%96%E7%A8%8B/c++%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
    <url>/2024/03/09/%E7%BC%96%E7%A8%8B/c++%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="c-c-的输入输出"><a href="#c-c-的输入输出" class="headerlink" title="c\c++的输入输出"></a>c\c++的输入输出</h2><h3 id="c语言的输入输出"><a href="#c语言的输入输出" class="headerlink" title="c语言的输入输出"></a>c语言的输入输出</h3><h5 id="gets"><a href="#gets" class="headerlink" title="gets()"></a>gets()</h5><p>按下回车键时，从stdin读取一行。<br>用法示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> str[<span class="hljs-number">100</span>];<br>gets(str);<br></code></pre></td></tr></table></figure><p>对空白字符的处理：<br>1.所有空格、Tab等空白字符均被读取，不忽略。<br>2.按下回车键时，缓冲区末尾的换行符被丢弃，字符串末尾没有换行符\n，缓冲区也没有残留的换行符\n。<br>注意，gets()不能指定读取上限，因此容易发生数组边界溢出，造成<strong>内存不安全</strong>。C11 使用了gets_s()代替gets()，但有时编译器未必支持，因此总体来说不建议使用gets()函数来读取输入。</p><p>gets()对应的输出函数是puts()。</p><h5 id="fgets"><a href="#fgets" class="headerlink" title="fgets()"></a>fgets()</h5><p>从指定输入流读取一行，输入可以是stdin，也可以是文件流，使用时需要显式指定。</p><p>读取stdin示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> s1[<span class="hljs-number">1005</span>];<br>fgets(s1,<span class="hljs-number">1004</span>,<span class="hljs-built_in">stdin</span>);<span class="hljs-comment">//换行符占两个字符</span><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> str[<span class="hljs-number">100</span>];<br><span class="hljs-built_in">memset</span>(str, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(str));<br><span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (fgets(str, <span class="hljs-keyword">sizeof</span>(str), <span class="hljs-built_in">stdin</span>) != <span class="hljs-literal">NULL</span>)<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;line%d [len %d]: %s&quot;</span>, i++, <span class="hljs-built_in">strlen</span>(str), str);<br></code></pre></td></tr></table></figure><p>对空白字符的处理：</p><p>1.所有空格、Tab等空白字符均被读取，不忽略。<br>2.按下回车键时，缓冲区末尾的换行符也被读取，字符串末尾将有一个换行符\n。例如，输入字符串hello，再按下回车，则读到的字符串长度为6。<br>3.fgets()函数会自动在字符串末尾加上\0结束符。</p><p>第 2 个参数n指定了读取的最大长度。函数读到n-1个字符（包括换行符\n）就会停止，并在末尾加上\0结束符。剩余字符将残留在缓冲区。</p><p>建议使用fgets()完全替代gets()。fgets()对应的输出函数是fputs()。</p><h5 id="fgetc-getc"><a href="#fgetc-getc" class="headerlink" title="fgetc &amp; getc()"></a>fgetc &amp; getc()</h5><p>从指定输入流读取一个字符，输入可以是<code>stdin</code>，也可以是文件流，使用时需要显式指定。</p><h5 id="getchar"><a href="#getchar" class="headerlink" title="getchar()"></a>getchar()</h5><p>从stdin读取一个字符。getchar()实际上也由fgetc()宏定义而来，只是默认输入流为stdin。</p><p>用法示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> a;<br>a = getchar();<br></code></pre></td></tr></table></figure><p>getchar()常常用于清理缓冲区开头残留的换行符。当知道缓冲区开头有\n残留时，可以调用getchar()但不赋值给任何变量，即可实现冲刷掉\n的效果。</p><p>getchar()对应的输出函数是putchar()。</p><h3 id="c-的输入输出"><a href="#c-的输入输出" class="headerlink" title="c++的输入输出"></a>c++的输入输出</h3><h5 id="cin"><a href="#cin" class="headerlink" title="cin"></a>cin</h5><p>cin是 C++ 的标准输入流对象，即istream类的一个对象实例。cin有自己的缓冲区，但默认情况下是与stdin同步的，因此在 C++ 中可以混用 C++ 和 C 风格的输入输出（在不手动取消同步的情况下）。</p><p>cin与stdin一样是行缓冲，即遇到换行符时才会将数据同步到输入缓冲区。</p><p>cin的用法非常多，只列举常用的几种。最常用的就是使用&gt;&gt;符号（我认为该符号形象地体现了“流”的特点）。</p><p>用法示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> a, b;<br>cin &gt;&gt; a &gt;&gt; b;<br><span class="hljs-type">char</span> str[<span class="hljs-number">20</span>];<br>cin &gt;&gt; str;<br></code></pre></td></tr></table></figure><p>cin对空白字符的处理与scanf一致。即：跳过开头空白字符，遇到空白字符停止读取，且空白字符（包括换行符）残留在缓冲区。</p><p>如果不想跳过空白字符，可以使用流控制关键词noskipws（no skip white space），但这只对单个字符有效（类似于scanf中的%c）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">char</span> c;<br>cin &gt;&gt; noskipws &gt;&gt; c;<br></code></pre></td></tr></table></figure><p>注意，cin对象属于命名空间std，如果想使用cin对象，必须在 C++ 文件开头写using namespace std，或者在每次用到的时候写成std::cin。</p><h5 id="cin-get"><a href="#cin-get" class="headerlink" title="cin.get()"></a>cin.get()</h5><p>读取单个或指定长度的字符，包括空白字符。</p><p>用法示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">char</span> a, b;<br><span class="hljs-type">char</span> str[<span class="hljs-number">20</span>];<br><br><span class="hljs-comment">// 读取一个字符，读取失败时返回0，多余字符残留在缓冲区（包括换行符）</span><br>a = cin.<span class="hljs-built_in">get</span>();<br><span class="hljs-comment">// 读取一个字符，读取失败时返回EOF，多余字符残留在缓冲区（包括换行符）</span><br>cin.<span class="hljs-built_in">get</span>(b);<br><br><span class="hljs-comment">// 在遇到指定终止字符（参数3）前，至多读取n-1个（参数2）字符</span><br><span class="hljs-comment">// 当不指定终止字符时，默认为换行符\n</span><br><span class="hljs-comment">// 如果输入的字符个数小于等于n-1（不含终止字符），则终止字符不残留在缓冲区</span><br><span class="hljs-comment">// 如果输入的字符个数多于n-1（不含终止字符），则余下字符将残留在缓冲区</span><br>cin.<span class="hljs-built_in">get</span>(str, <span class="hljs-built_in">sizeof</span>(str), <span class="hljs-string">&#x27;\n&#x27;</span>);<br></code></pre></td></tr></table></figure><p>cin.get()读取单个字符时，类似于 C 中的fgetc()，对空白字符的处理也与其一致。cin.get()读取的字符也可以赋值给整型变量。</p><p>cin.get()读取指定长度个字符时，类似于 C 中的fgets()，但在换行符的处理上不同。它们都不会使换行符残留在缓冲区，但fgets()会将缓冲区末尾的换行符\n也写入字符串，而cin.get()会丢弃缓冲区末尾的\n。即：当输入test时，用fgets()读取得到的字符串长度为5，用cin.get()读取得到的字符串长度为4。</p><h5 id="cin-getline"><a href="#cin-getline" class="headerlink" title="cin.getline()"></a>cin.getline()</h5><p>读取指定长度的字符，包括空白字符。</p><p>用法示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">char</span> str[<span class="hljs-number">20</span>];<br>cin.<span class="hljs-built_in">getline</span>(str, <span class="hljs-built_in">sizeof</span>(str));    <span class="hljs-comment">// 第3个参数也可以指定终止字符</span><br></code></pre></td></tr></table></figure><p>cin.getline()与cin.get()指定读取长度时的用法几乎一样。区别在于，如果输入的字符个数大于指定的最大长度n-1（不含终止符），cin.get()会使余下字符残留在缓冲区，等待下次读取；而cin.getline()会给输入流设为 Fail 状态，在主动恢复之前，无法再进行正常输入。</p><h5 id="getline"><a href="#getline" class="headerlink" title="getline()"></a>getline()</h5><p>getline()并不是标准输入流istream的函数，而是字符串流sstream的函数，只能用于读取数据给<strong>string类对象</strong>，使用时也需要包含头文件<string>。</p><p>如果使用getline()读取标准输入流的数据，需要显式指定输入流。</p><p>用法示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">string str;<br><span class="hljs-built_in">getline</span>(cin, str);<br></code></pre></td></tr></table></figure><p>getline()会读取所有空白字符，且缓冲区末尾的换行符会被丢弃，不残留也不写到字符串结尾。同时，由于string对象的空间是动态分配的，所以会一次性将缓冲区读完，不存在读不完残留在缓冲区的问题。</p><p>需要注意的是，假如缓冲区开头就是换行符（比如可能是上一次cin残留的），则getline()会直接读取到空字符串并结束，不会给键盘输入的机会。所以这种情况下要注意先清除开头的换行符。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在 C 中，建议使用scanf()进行格式化读取，用fgets()读取整行，用fgetc()或getchar()读取单个字符。</p><p>在 C++ 中，建议使用cin &gt;&gt;进行格式化读取，而cin.get()、cin.getline、getline(string)有各自的适用情况。</p><p>注意fgets()和cin.get()在对换行符的清理方面有所区别。</p>]]></content>
    
    
    <categories>
      
      <category>编程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>rc4加密</title>
    <link href="/2024/03/09/%E9%80%86%E5%90%91/rc4%E5%8A%A0%E5%AF%86/"/>
    <url>/2024/03/09/%E9%80%86%E5%90%91/rc4%E5%8A%A0%E5%AF%86/</url>
    
    <content type="html"><![CDATA[<p>​<a href="https://en.wikipedia.org/wiki/RC4">RC4（来自Rivest Cipher 4）</a>由美国密码学家罗纳德·李维斯特（Ron Rivest）在1987年设计，是一种流加密算法，密钥长度可变。它加解密使用相同的密钥，因此也属于对称加密算法。RC4是有线等效加密（WEP）中采用的加密算法，也曾经是TLS可采用的算法之一。由于RC4算法存在弱点，2015年2月所发布的 <a href="https://tools.ietf.org/html/rfc7465">RFC 7465</a> 规定禁止在TLS中使用RC4加密算法。</p><p>加密流程：</p><p>![image-20240304081609314](&#x2F;Users&#x2F;mawenhui&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20240304081609314.png)</p><p>具体加密过程：</p><p>1、先初始化状态向量S（256个字节，用来作为密钥流生成的种子1）</p><p>按照升序，给每个字节赋值0,1,2,3,4,5,6…..,254,255</p><p>2、初始密钥（由用户输入），长度任意</p><p>如果输入长度小于256个字节，则进行轮转，直到填满</p><p>例如输入密钥的是1,2,3,4,5  , 那么填入的是1,2,3,4,5,1,2,3,4,5,1,2,3,4,5……..</p><p>由上述轮转过程得到256个字节的向量T（用来作为密钥流生成的种子2）</p><p>3、开始对状态向量S进行置换操作（用来打乱初始种子1）</p><p>按照下列规则进行</p><p>从第零个字节开始，执行256次，保证每个字节都得到处理　</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++">j = <span class="hljs-number">0</span>;<br><br>　　<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span> ; i &lt; <span class="hljs-number">256</span> ; i++)&#123;<br><br>　　　　j = (j + S[i] + T[i]) mod <span class="hljs-number">256</span>;<br><br>　　　　<span class="hljs-built_in">swap</span>(S[i] , S[j]);<br><br>　　&#125;<br></code></pre></td></tr></table></figure><p>这样处理后的状态向量S几乎是带有一定的随机性了</p><p>4、密钥流的生成与加密</p><p>假设我的明文字节数是datalength&#x3D;1024个字节（当然可以是任意个字节）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++">i=<span class="hljs-number">0</span>;<br><br>j=<span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">while</span>(datalength--)&#123;<span class="hljs-comment">//相当于执行1024次，这样生成的秘钥流也是1024个字节</span><br>i = (i + <span class="hljs-number">1</span>) mod <span class="hljs-number">256</span>;<br>  j = (j + S[i]) mod <span class="hljs-number">256</span>;<br>  <span class="hljs-built_in">swap</span>(S[i] , S[j]);<br>  t = (S[i] + S[j]) mod <span class="hljs-number">256</span>;<br>  k = S[t];<span class="hljs-comment">//这里的K就是当前生成的一个秘钥流中的一位</span><br>    <span class="hljs-comment">//可以直接在这里进行加密，当然也可以将密钥流保存在数组中，最后进行异或就ok</span><br>    <span class="hljs-comment">//data[]=data[]^k； 进行加密，&quot;^&quot;是异或运算符</span><br><br>&#125;<br></code></pre></td></tr></table></figure><p>解密过程：把密文异或</p><p>c语言实现代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> longULONG;<br><br><span class="hljs-comment">/* 初始化算法（KSA）函数</span><br><span class="hljs-comment"> *参数 1: 一个 256 长度的 char 型数组，定义为: unsigned char sBox[256];</span><br><span class="hljs-comment"> *参数 2: 密钥，其内容可以随便定义：char key[256];</span><br><span class="hljs-comment"> *参数 3: 密钥的长度，Len = strlen(key);</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">rc4_init</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>* s, <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>* key, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> Len)</span><br>&#123;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">char</span> k[<span class="hljs-number">256</span>] = &#123; <span class="hljs-number">0</span> &#125;;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> tmp = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">256</span>; i++)<br>    &#123;<br>        s[i] = i;<br>        k[i] = key[i%Len];<br>    &#125;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">256</span>; i++)<br>    &#123;<br>        j = (j + s[i] + k[i]) % <span class="hljs-number">256</span>;<br>        tmp = s[i];<br>        s[i] = s[j]; <span class="hljs-comment">// 交换 s[i] 和 s[j]</span><br>        s[j] = tmp;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/* 伪随机子密码生成算法（PRGA）函数完成加、解密。</span><br><span class="hljs-comment"> * 过程中，密钥的主要功能是将 S 搅乱，i 确保 S 的每个元素都得到处理，j 保证 S 的搅乱是随机的。</span><br><span class="hljs-comment"> * 由此，不同的 S 在经过 PRGA 处理后可以得到不同的子密钥序列，将 S 和明文进行 xor 运算，得到密文，解密过程也完全相同。</span><br><span class="hljs-comment"> * 参数 1：是上边 rc4_init 函数中，被搅乱的 S;</span><br><span class="hljs-comment"> * 参数 2：是需要加密的 Data 数据;</span><br><span class="hljs-comment"> * 参数 3：是 Data 的长度。</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">rc4_crypt</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>* s, <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>* Data, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> Len)</span><br>&#123;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>, t = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> k = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> tmp;<br>    <span class="hljs-keyword">for</span> (k = <span class="hljs-number">0</span>; k &lt; Len; k++)<br>    &#123;<br>        i = (i + <span class="hljs-number">1</span>) % <span class="hljs-number">256</span>;<br>        j = (j + s[i]) % <span class="hljs-number">256</span>;<br>        tmp = s[i];<br>        s[i] = s[j]; <span class="hljs-comment">// 交换 s[x] 和 s[y]</span><br>        s[j] = tmp;<br>        t = (s[i] + s[j]) % <span class="hljs-number">256</span>;<br>        Data[k] ^= s[t];<br>    &#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> s[<span class="hljs-number">256</span>] = &#123; <span class="hljs-number">0</span> &#125;, s2[<span class="hljs-number">256</span>] = &#123; <span class="hljs-number">0</span> &#125;;   <span class="hljs-comment">// S</span><br>    <span class="hljs-type">char</span> key[<span class="hljs-number">256</span>] = &#123; <span class="hljs-string">&quot;justfortest&quot;</span> &#125;;<br>    <span class="hljs-type">char</span> pData[<span class="hljs-number">512</span>] = <span class="hljs-string">&quot;这是一个用来加密的数据 Data&quot;</span>;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> len = <span class="hljs-built_in">strlen</span>(pData);<br>    <span class="hljs-type">int</span> i;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;pData=%s\n&quot;</span>, pData);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;key=%s, length=%zu\n\n&quot;</span>, key, <span class="hljs-built_in">strlen</span>(key));<br>rc4_init(s, (<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>*)key, <span class="hljs-built_in">strlen</span>(key));   <span class="hljs-comment">// 已经完成了初始化</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;完成对 S[i] 的初始化，如下：\n\n&quot;</span>);<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i&lt;<span class="hljs-number">256</span>; i++)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%02X&quot;</span>, s[i]);<br>        <span class="hljs-keyword">if</span> (i &amp;&amp; (i + <span class="hljs-number">1</span>) % <span class="hljs-number">16</span> == <span class="hljs-number">0</span>)<span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;\n&#x27;</span>);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n\n&quot;</span>);<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i&lt;<span class="hljs-number">256</span>; i++)               <span class="hljs-comment">// 用 s2[i] 暂时保留经过初始化的 s[i]，很重要！</span><br>    &#123;<br>        s2[i] = s[i];<br>    &#125;<br> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;已经初始化，现在加密: \n\n&quot;</span>);<br>    rc4_crypt(s, (<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>*)pData, len);        <span class="hljs-comment">// 加密</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;pData=%s\n\n&quot;</span>, pData);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;已经加密，现在解密: \n\n&quot;</span>);<br>    rc4_crypt(s2, (<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>*)pData, len);       <span class="hljs-comment">// 解密</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;pData=%s\n\n&quot;</span>, pData);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>逆向</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
